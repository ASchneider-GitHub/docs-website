---
title: "Use advanced NRQL functions"
tags:
  - NRQL tutorial
  - 'NRQL: New Relic query language'
  - Get started
  - Tutorial
metaDescription: "Learn how to use advanced NRQL functions"
---

import queriesnrql4tutorial1 from 'images/queries-nrql_screenshot-crop-tutorial4-1.webp'

import queriesnrql4tutorial2 from 'images/queries-nrql_screenshot-crop-tutorial4-2.webp'

import queriesnrql4tutorial3 from 'images/queries-nrql_screenshot-crop-tutorial4-3.webp'

import queriesnrql4tutorial4 from 'images/queries-nrql_screenshot-crop-tutorial4-4.webp'

import queriesnrql4tutorial5 from 'images/queries-nrql_screenshot-crop-tutorial4-5.webp'

import queriesnrql4tutorial6 from 'images/queries-nrql_screenshot-crop-tutorial4-6.webp'

import queriesnrql4tutorial7 from 'images/queries-nrql_screenshot-crop-tutorial4-7.webp'

import queriesnrql4tutorial8 from 'images/queries-nrql_screenshot-crop-tutorial4-8.webp'

import queriesnrql4tutorial9 from 'images/queries-nrql_screenshot-crop-tutorial4-9.webp'

import queriesnrql4tutorial10 from 'images/queries-nrql_screenshot-crop-tutorial4-10.webp'

import queriesnrql4tutorial11 from 'images/queries-nrql_screenshot-crop-tutorial4-11.webp'

import queriesnrql4tutorial12 from 'images/queries-nrql_screenshot-crop-tutorial4-12.webp'

import queriesnrql4tutorial13 from 'images/queries-nrql_screenshot-crop-tutorial4-13.webp'

import queriesnrql4tutorial14 from 'images/queries-nrql_screenshot-crop-tutorial4-14.webp'

import queriesnrql4tutorial15 from 'images/queries-nrql_screenshot-crop-tutorial4-15.webp'

Welcome to level 4! Thanks for continuing on this journey with us. We have already learned so much, and witnessed the incredible power of NRQL together. You're already a dashboarding and alerting hero!

This next section will discuss additional aggregation techniques, higher-level math functions, and advanced features like Regex filtering, and nested aggregation. Specifically, you'll learn how to use:

* The stddev() aggregation function, and how to group aggregated data using the buckets() function
* The advanced math functions available within NRQL to smooth, clamp and manipulate the data
* How to discover the event types and attributes available in your data within a specific period
* How to filter data with Regex using RLIKE
* How to use nested aggregation and subqueries

We think you'll find these features downright invaluable. Let's get started! (Remember if your account doesn't have Transaction event data the queries will fall back to safer queries)

### Use bucketing with aggregation

<Steps>
    <Step>
*Standard Deviation and Variance*
Standard deviation mesaures the amount of variation or dispersion within a set of values. It uses a scale from low (values close to the average) to high (values far from the average). The stddev()function lets us look between the lines of averages and understand what values are reported on a deeper level. In this example, we compare standard deviation of transaction response time ("duration") for the last day to the previous day.   

```sql
SELECT stddev(duration) 
FROM Transaction 
SINCE 24 hours ago 
COMPARE WITH 24 hours ago 
TIMESERIES
```
<img
    title="INSERT_TITLE_HERE"
    alt="INSERT_ALT_TEXT_HERE"
    src={queriesnrql4tutorial1}
/>

The stdvar() function works in a similar way to stddev() but returns the standard variance for numeric attributes.
    </Step>
    <Step>
*Facet Bucketing*
In a previous lesson, we learned how to group data into a specific configuration of buckets using FACET cases(). We can also bucket data by a specific attribute automatically using FACET buckets(). This function simplifies grouping data for any aggregation function. It takes three arguments: 
`buckets(attribute, ceiling, number-of-buckets)`.

* The attribute we want to bucket by.
* Maximum value of the sample range. (Any outliers will appear in the final bucket)
* The total number of buckets we require.

In the example query, we ask for the average duration of an entire transaction; but we want to group that performance into transactions that make specific volumes of database calls. So, we specify the bucket attribute as databaseCallCount, set the ceiling at 400 calls, and group it in 10 buckets. The result is the performance of transactions making 0-40, 40-80, 80-120, 120-160, 160-200, 200-240, 240-280, 280-320, 320-360, and >360 Database Calls. 10 clear buckets divided evenly up to the ceiling.        

```sql
SELECT average(duration) 
FROM Transaction 
SINCE 12 hours ago 
FACET buckets(databaseCallCount, 400, 10)
```
<img
    title="INSERT_TITLE_HERE"
    alt="INSERT_ALT_TEXT_HERE"
    src={queriesnrql4tutorial2}
/>
    </Step>

You have now learned all aggregation functions that curently exist in NRQL! You can slice and dice your data like a pro. If you think an aggregation ability is missing from NRQL, let your account team know. We are always looking for the next killer functionality our customers need.
</Steps>

### Use advanced math functions

NRQL also supports some nifty, more advanced mathetmatical functions for those who need to get nitty-gritty with their data. These functions can extrapolate values to power of X, find square roots, apply clamping to impose upper and lower bounds, or even just keep values postive on the Y axis.

<Steps>
    <Step>
*Absolute and Integer Rounding*
NRQL has many math functions that manipulate values in some way. In this example, we will demonstrate a few simultaneously.

The abs(n) function returns the absolute value for n: for non-negative n values it returns n, and for negative n values it returns the positive number n. For example, abs(2) = 2, and abs(-4) = 4. Fortunately, duration is always positive, but we want to demonstrate how straightforward this can be.

We can also round decimal numbers to integers using floor(), ceil(), and round(). floor() returns the closest full integer rounding down, and ceil() does the opposite by rounding up. round() is bi-directional and will round up or down to the closest full integer.

```sql
SELECT abs(duration), round(duration), ceil(duration), floor(duration) 
FROM Transaction 
SINCE 1 day ago
```
<img
    title="INSERT_TITLE_HERE"
    alt="INSERT_ALT_TEXT_HERE"
    src={queriesnrql4tutorial3}
/>
    </Step>
    <Step>
*Data Clamping*

We can use clamping on an attribute to impose an upper or lower limit on its value. This is useful for things like ensuring extreme outliers don't skew the scale of a timeseries graph. clamp_max(duration, 10) returns the duration, unless it exceeds 10, in which case 10 is returned. Quite simply, anything greater than 10 is forced to equal 10. clamp_min(duration,1) does the inverse; if any duration is below 1, it is forced to equal 1. 

```sql
SELECT clamp_max(average(duration), 10), clamp_min(average(duration), 1) 
FROM Transaction 
SINCE 1 day ago 
TIMESERIES
```
<img
    title="INSERT_TITLE_HERE"
    alt="INSERT_ALT_TEXT_HERE"
    src={queriesnrql4tutorial4}
/>
    </Step>
    <Step>
*Powers, Roots, Exponential, and Logs*
Now we are onto the advanced maths some of us found challenging in school! As before, we can demonstrate all these functions in a single example query.

The pow() function raises the first argument to the power of the second argument. In our example, we raise duration to the power of 2. If you need the square root of a value, the sqrt() function can quickly provide this. And the exp() function computes the natural exponential function of its argument.

Finally, NRQL also offers logarithms catered to a number of similar functions:

* ln(n) computes the natural logarithm: the logarithm base e.
* log2(n) computes the logarithm base 2.
* log10(n) computes the logarithm base 10.
* log(n, b) allows logarithms to be computed with an arbitrary base b.   

```sql
SELECT pow(duration, 2), sqrt(duration), exp(duration), ln(duration), log2(duration) 
FROM Transaction 
SINCE 1 day ago
```
<img
    title="INSERT_TITLE_HERE"
    alt="INSERT_ALT_TEXT_HERE"
    src={queriesnrql4tutorial5}
/>
    </Step>

In this lesson, we learned about smoothing event data. round()/ceil()/floor() let us round in whichever manner suits us. Clamping lets us put bounds on the data. And our advanced mathematic tools for logarithm, square root, power and exponential all offer further control to manipulate and plot data however we need.
</Steps>

### Discover events and attributes

Discovering Events and Attributes can help both answer questions about your available data before querying it, and assist with automation! Let's take a moment to explore this powerful utility.

<Steps>
    <Step>
*Discovering Event Types*

Let's say you want a list of all event types currently reporting to your New Relic account. The SHOW EVENT TYPES syntax returns a list of all reported event types in a given period. This is one of the rare exceptions where SELECT and FROM are not required in a NRQL query. You could use this functionality for things like confirming the existence of custom event data, for example.

```sql
SHOW EVENT TYPES 
SINCE 1 week ago
```
<img
    title="INSERT_TITLE_HERE"
    alt="INSERT_ALT_TEXT_HERE"
    src={queriesnrql4tutorial6}
/>
    </Step>
    <Step>
*Discovering Attributes*

You may need to know what attributes are available for a given event type. The keyset() function provides a list of all attributes for an event type, grouped by attribute type. Note that only attributes that contain values within the provided time window will be returned. You can use this to explore your data. You can also use it in automation, for things like ensuring customer data is reporting correctly.        

```sql
SELECT keyset() 
FROM Transaction 
SINCE 1 week ago
```
<img
    title="INSERT_TITLE_HERE"
    alt="INSERT_ALT_TEXT_HERE"
    src={queriesnrql4tutorial7}
/>
    </Step>
These features help you discovery of changes in event types and/or attributes. More DevOps engineers use these functionalities to wrap up jobs, or even quickly automate them.
</Steps>

### Filter with Regex
<Steps>
    <Step>
You may occasionally want to filter data with more complex pattern matching than is provided by LIKE. With the RLIKE clause, we can filter with regular expression for more complicated matching.

In any scenario you could use LIKE, you now have the option to use RLIKE, and provide corresponding Regex in quotations. In this example, we list all host names ending in even numbers or consonants.

<SideBySide>
    <Side>
        ```sql
        SELECT uniques(host) 
        FROM Transaction 
        WHERE host 
        RLIKE '^.*[02468bcdfghjklmnpqrstvwxyz]'
        ```
    </Side>
    <Side>
<img
    title="INSERT_TITLE_HERE"
    alt="INSERT_ALT_TEXT_HERE"
    src={queriesnrql4tutorial8}
/>
    </Side>
</SideBySide>

    </Step>
    <Step>
You can also do simple matching. For instance, maybe you want to match a value that starts with a given letter or word.

        ```sql
        SELECT count(*) 
        FROM Transaction 
        WHERE name 
        RLIKE 'W.*|O.*' 
        FACET name
        ```

The regular expression engine uses RE2 syntax. If you need to escape characters, you may need to use double backslashing escape sequences. e.g. \\*

Know that RLIKE is inherently more complex and less performant than LIKE. Only use it when LIKE and other filtering functionality does not fit your needs.       
    </Step>
Regular expression support allows for near-infinite pattern matching possibilities. If you are already a Regex guru, you know the power this adds to NRQL. But if you're not, don't worry! There are tons of Regex resources available to reference online.
</Steps>

### Use nested aggregation

With NRQL you can write nested aggregation queries, where a NRQL query is used as the 'FROM' for the parent query. This allows you to answer questions such as:

* How many transactions per minute did my application handle, and what was the maximum rate of requests per minute in the last hour?
* What is the average CPU usage of all my servers, and which specific servers are over 90%?
* What percentage of all user sessions bounced immediately (i.e. only one PageView in the session)?

Let's explore each of these use cases in more detail.

<Steps>
    <Step>
*Example 1 - Max TPM for Last Hour*
First we count the number of transactions per minute over the last hour. There is nothing new here. This returns 60 data points on a graph:

```sql
SELECT count(*) AS tpm 
FROM Transaction 
TIMESERIES 1 MINUTE
```
<img
    title="INSERT_TITLE_HERE"
    alt="INSERT_ALT_TEXT_HERE"
    src={queriesnrql4tutorial10}
/>

Now, in order to find the maximum value reported across that period, we wrap the query in parentheses, and use SELECT ... FROM like this: SELECT z FROM (SELECT x AS z FROM y)

```sql
SELECT max(apicalls) 
FROM ( SELECT count(*) AS apicalls FROM Public_APICall TIMESERIES 1 minute )
```
    </Step>
    <Step>
*Example 2 - Servers with High CPU Load*

This example uses data from New Relic Infrastructure. Sometimes you only want to see hosts whose CPU has, on average, exceeded a certain percentage. If you ask NRQL for the average(cpuPercent) you get a list of hosts with the highest average CPU percent. But you cannot simply add a WHERE cpuPercent > 90 to limit this to only hosts running at 90% or above, because this would remove the data before calculating the average.

But this can be solved with nested aggregation! By asking for average(cpuPercent) in the sub query, we get the list of hosts and their average CPU. Now, in the outer query we can filter to only results that were > x%. Happy days! (Tip: You may need to adjust the threshold of this query to work with your hosts' CPU. We've set it to 20% here.)       

```sql
SELECT query, avgduration 
FROM (SELECT average(durationMs) as avgduration from NrdbQuery FACET query) 
WHERE avgduration > 40
```

<img
    title="INSERT_TITLE_HERE"
    alt="INSERT_ALT_TEXT_HERE"
    src={queriesnrql4tutorial11}
/>
    </Step>
    <Step>
*Example 3 - Session Bounces*

We are often asked how to calculate bounce rate on front-end monitoring. This refers to sessions that view a single page, and "bounce" away before visiting more pages. With nested aggregation, we can achieve this. Our inner query counts the PageViews, grouping them by session. The result set passed to the outer query is a list of all sessions and how many pages each viewed. The outer query then calculates the percentage of sessions in which the count is 1 (this indicates a "bounced session", because they only viewed a single page). 

```sql
SELECT percentage(count(*), where avgduration > 20 ) 
FROM (select average(durationMs) as avgduration FROM NrdbQuery facet query)
```
    </Step>
In this lesson we have learned how we can use a query as the FROM of another query to answer more complicated questions.
</Steps>

### Use subqueries

Subqueries in NRQL are similar to nested aggregations, allowing you to use a query nested inside another query. With subqueries the nested query is used in the SELECT statement and the WHERE clause, while nested aggregations are used in the FROM clause.

Let's look at some examples of these different types of subqueries.

<Steps>
    <Step>
*Numeric Conditions*

Any query which returns a single numeric value can be used in numeric conditions. This example uses a subquery in the WHERE clause that returns the value for the 97th percentile of the duration for the transactions, and then returns the name and the duration for those transactions that are greater than that.

```sql
SELECT http.url, duration 
FROM Public_APICall 
WHERE duration > (SELECT percentile(duration,97) FROM Public_APICall)
```
<img
    title="INSERT_TITLE_HERE"
    alt="INSERT_ALT_TEXT_HERE"
    src={queriesnrql4tutorial12}
/>
    </Step>
    <Step>
*IN Conditions*

Where multiple values are returned from a subquery, use an IN condition for the parent query to compare against each value. In the example, the entity.guid attribute for each unique entity that has a transaction error is returned, and this is matched against the entity.guid value for the transactions to determine the average duration for the erroring entities.

```sql
SELECT average(duration) 
FROM Public_APICall 
WHERE api IN (SELECT uniques(api) FROM Public_APICall where duration > 2) 
FACET api 
TIMESERIES
```
<img
    title="INSERT_TITLE_HERE"
    alt="INSERT_ALT_TEXT_HERE"
    src={queriesnrql4tutorial13}
/>
    </Step>
    <Step>
*Subqueries in the SELECT statement*

Subquery results can be used in calculations in the SELECT statement, and may specify a different time range from the outer query. This example calculates the delta between the current average duration and that of the last 7 days. 

```sql
SELECT average(duration) - (SELECT average(duration) FROM Public_APICall SINCE 7 days ago) 
FROM Public_APICall 
TIMESERIES
```
<img
    title="INSERT_TITLE_HERE"
    alt="INSERT_ALT_TEXT_HERE"
    src={queriesnrql4tutorial14}
/>
    </Step>
Subqueries are a powerful tool for data exploration, allowing for more sophisticated queries across different data sources and time ranges.
</Steps>

<CollapserGroup>
    <Collapser
        id="summary"
        title="Lesson summary"
    >
Congratulations on completing Level 4: NRQL Power User!

In this section we covered additional aggregation techniques, higher-level math functions, and advanced features like Regex filtering, nested aggregation and subqueries.

If you have further questions or encounter problems, feel free to [contact New Relic support](https://support.newrelic.com/). You're also welcome to share your experience with our [online community](https://discuss.newrelic.com/).
    </Collapser>
</CollapserGroup>
