---
title: Understanding and using timestamps in logs
tags:
  - Logs
  - Timestamp
  - Timestamps
  - Forwarding Logs
metaDescription: "How New Relic handles timestamps in logs."
---

A log event leaves behind a timestamp attribute, which tells you the exact moment a certain event happened. Timestamps are critical for ordering events. They let you search logs for specific timeframes so you can discover what and when something happened.  

Timestamps have many formats without a single standard. They appear at the beginning of the log event for most cases, but can sometimes appear much later in the log, or not at all.

* By default, New Relic assigns the value of the log `timestamp` attribute (a reserved keyword) at the exact time the log is ingested. This is referred to as at ingest time.
* When logs don't have a timestamp, New Relic assigns a timestamp at time of ingest. 
* Logs in a JSON format contain some attribute that identifies the timestamp, like `timestamp`, `log_timestamp`, `time`, etc.  
* If we receive JSON logs with with a supported timestamp format, we override our ingest timestamp with the JSON attribute.

## Format your logs timestamp [#format]

There are two options to manually override default behavior and assign the `timestamp` value based on a `timestamp` contained in the log.

1. If we receive a [JSON formatted log](#timestamps_in_json_logs) containing a `timestamp` attribute in one of our supported time formats, we will override the ingest timestamp value with the value of the timestamp from the json attribute.
2. You can use [parsing rules](#timestamp_parsing_rules) at ingest to override the ingest `timestamp` value to the timestamp value that is contained in the log.  Using a parsing rule you can extract out our supported time formats with simple Grok expressions, or by using the `datetime` Grok type and a `pattern` to define the custom timestamp format in your log.

We support two timestamp formats:

- A unix **epoch** timestamp:
  - The number of seconds (or milliseconds) that have elapsed since 00:00:00 UTC on 1 January 1970.
  - Some examples (Fri, 03 Nov 2023 16:06:32 GMT):
    - 10-digit epoch seconds time: `1699027592`
    - 13-digit epoch milliseconds time: `1699027592000`

- An **ISO8601 formatted timestamp**:
  - Timestamps in this format must follow the pattern yyyy-MM-ddTHH:mm:ss.SSSTZD (e.g. 2023-11-07T14:20:35+04:00) where: 
    - yyyy: four-digit year
    - MM: two-digit month (01=January, etc.)
    - dd: two-digit day of the month (01 through 31)
    - T: a set character indicating the start of the time element
    - HH: two digits of an hour (00 through 23)
    - mm: two digits of a minute (00 through 59)
    - ss: two digits of a second (00 through 59)
    - SSS: three digits of a millisecond (optional). Up to nine digits are allowed here, but only the first three will be taken into account. 
    - TZD: time zone designator (Z or +hh:mm or -hh:mm) (optional). The + or - values indicate how far ahead or behind a time zone is from the UTC (Coordinated Universal Time) zone. If this value is not provided, UTC is assumed.   
  - Some ISO8601 timestamp format examples:
    - yyyy-MM-ddTHH:mm:ss: `2023-11-03T15:28:05`
    - yyyy-MM-ddTHH:mm:ss.SSS: `2023-11-03T15:28:05.250`
    - yyyy-MM-ddTHH:mm:ssZ: `2023-11-03T15:28:05Z`
    - yyyy-MM-ddTHH:mm:ss+HH:mm: `2023-11-03T15:28:05+07:00`

  - The maximum precision for timestamps is milliseconds.  Timestamps expressed more precisely (e.g. nanoseconds or microseconds) will be automatically truncated to milliseconds.
 
## Timestamps in JSON logs [#timestamps_in_json_logs]

If we receive a JSON formatted log containing a `timestamp` attribute in one of our supported time formats, we will override the ingest `timestamp` value with the value of the `timestamp` from the json attribute. 

The data type will be:
- A number, for Unix epoch seconds or milliseconds timestamp
- A string, for ISO8601 formatted timestamp

Other considerations:
- If the timestamp field is not present or incorrectly specified (for example, with an invalid format), the message will be timestamped using the ingest time.
- Timestamps are converted to Unix epoch milliseconds and stored internally as a long data type, with the reserved keyword `timestamp`.
- Payloads with timestamps older than 48 hours will be dropped.

Depending on the JSON body format, ​the timestamp field can be allocated in four different places:
- Inside the [simplified set of attributes](https://docs.newrelic.com/docs/logs/log-api/introduction-log-api/#simple-json) of the JSON body message when sending a single JSON object.
- Inside the [common](https://docs.newrelic.com/docs/logs/log-api/introduction-log-api/#json-common) object in the detailed set of attributes of the JSON body message when sending one or more JSON objects. The timestamp will apply to all log messages of this JSON.
- Inside each log message in the [logs](https://docs.newrelic.com/docs/logs/log-api/introduction-log-api/#json-logs) object in the detailed set of attributes of the JSON body message when sending one or more JSON objects. The timestamps will only apply to that log message.
- In addition, the timestamp can be indicated in the “message” JSON field when it is a valid JSON message. Our log management capabilities will parse any message attribute as JSON. The resulting JSON attributes in the parsed message will be added to the log. (link) 

Below are some examples of JSON logs with a valid `timestamp` attribute that will override the ingest `timestamp`:

1. If we receive a JSON log like this with `timestamp` in **epoch** format (with no ms precision):

```
{ 
    "timestamp":1701445572,
    "message":"This is my sample JSON log message with timestamp attribute in epoch format"
}
```

We will override the ingest `timestamp` with the epoch `timestamp` contained in the log, and the result will look like this:

```
"timestamp" : 1701445572000,
"message":"This is my sample JSON log message with timestamp attribute in epoch format"
```

2. Or, if we receive a JSON log like this with timestamp in **ISO8601** format like this:

```
{
    "timestamp":"2023-12-01T15:46:26.607Z",
    "message":"This is my sample JSON log message with timestamp attribute in ISO8601 format"
}
```

We will override the ingest `timestamp` with the ISO8601 `timestamp` (converted to epoch) contained in the log, and the result will look like this:

```
"timestamp": 1701445586607,
"message":"This is my sample JSON log message with timestamp attribute in ISO8601 format"
```

## Setting the log timestamp using Parsing rules [#timestamp_parsing_rules]

You can use **parsing rules** at ingest to override the ingest `timestamp` value to the timestamp value that is contained in the log.  Using a parsing rule you can extract out our supported time formats with simple Grok expressions, or by using the `datetime` Grok type and `pattern` to define the custom timestamp format in your log. 

- The attribute name extracted by the expression must be `timestamp` and its data type string or long. If it is not provided, it defaults to string.  Note that for epoch timestamps with microsecond or nanosecond precision, you must include the `long` datatype even though timestamp precision will be truncated to milliseconds.
- If the timestamp in your log is a Unix epoch or ISO8601 formatted timestamp you can use the default Grok patterns to match them.
  - To extract a Unix epoch timestamp you can use any expression that matches the vale, like `NUMBER`, `NOTSPACE`, `DATA`, or `GREEDYDATA`.
  - To extract an ISO8601 formatted timestamp you should use the `TIMESTAMP_ISO8601` grok expression.
- You can use the `datetime` Grok type to parse timestamps in non-supported formats.  To do this you must include the `datetime` grok type with the `pattern` matching your logs timestamp format.  The `pattern` must use the Java Simple Date and Time Patterns found [here](https://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html).
  - Example: 
    - `timestamp` = 11/17/2023 23:55:25.674 
    - `pattern` = MM/dd/yyyy HH:mm:ss.SSS
    - Grok Expression = `%{GREEDYDATA:timestamp:datetime;MM/dd/yyyy HH:mm:ss.SSS}`
  - Example:
    - `timestamp` = 11-17-2023 23:55:25
    - `pattern` = MM-dd-yyyy HH:mm:ss
    - Grok Expression = `%{GREEDYDATA:timestamp:datetime;MM-dd-yyyy HH:mm:ss}`
  - Example:
    - `timestamp` = 11/17/2023 09:55:25 AM
    - `pattern` = MM/dd/yyyy hh:mm:ss a
    - Grok Expression = `%{GREEDYDATA:timestamp:datetime;h:mm:ss a}` 
 
Below are some examples on how to parse the `timestamp` from your logs using ingest Parsing rules:

1. For the following log message with timestamp in **ISO8601** format:

```
2023-12-05T16:50:48.421Z 146.190.212.184: This is my sample non-JSON log message with ISO8601 timestamp.
```

And the following parsing rule:

```
%{TIMESTAMP_ISO8601:timestamp}
```

Will parse your log as follows:

```
"ISO8601_TIMEZONE": "Z",
"message": "2023-12-05T16:50:48.421Z 146.190.212.184: This is my sample non-JSON log message with ISO8601 timestamp.",
"timestamp": 1701795048421
```

2. For the following log message with timestamp in **epoch** format:

```
1701795958504 146.190.212.184: This is my sample non-JSON log message with epoch (with ms) timestamp.
```

And the following parsing rule:

```
%{NUMBER:timestamp:long}
```

Will parse your log as follows:

```
"message": "1701795958504 146.190.212.184: This is my sample non-JSON log message with epoch (with ms) timestamp.",
"timestamp": 1701795958504
```

3. And for the following log message with an un-supported timestamp format:

```
12/05/2023 17:12:45.347 146.190.212.184: This is my sample non-JSON log message with un-supported timestamp.
```

And the following parsing rule:

```
^%{DATA:timestamp:datetime;MM/dd/yyyy HH:mm:ss.SSS} %{IP:ip}
```

Will parse your log as follows:

```
"ip": "146.190.212.184",
"message": "12/05/2023 17:12:45.347 146.190.212.184: This is my sample non-JSON log message with DATE_US timestamp.",
"timestamp": 1701796365347
```
