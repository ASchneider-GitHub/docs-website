---
title: "Instrument your non-containerized Lambda function"
metaDescription: Instrument your non-containerized Lambda function
freshnessValidatedDate: never
---
import serverlessNonContainerizedLambdaFunction from 'images/serverless_diagram_non-containerized-lambda-function.webp'

After you've successfully linked your New Relic and AWS accounts, you can instrument your non-containerized Lambda function.


<img
    title="non-containerized"
    alt="a diagram depicting non-containerized lambda function instrumentation"
    src={serverlessNonContainerizedLambdaFunction}
/>

## Before you begin [#begin]

* [Link your New Relic and AWS accounts](/docs/serverless-function-monitoring/aws-lambda-monitoring/instrument-lambda-function/introduction-lambda#link)
* [Review our different instrumentation methods](/docs/serverless-function-monitoring/aws-lambda-monitoring/instrument-lambda-function/introduction-lambda#method)

## Instrumentation methods [#instrumentation]
Below we've listed some instrumentation methods for New Relic Lambda monitoring. The CLI, serverless framework, CloudFormation/SAM, Terraform, and manual instrumentation methods all include the New Relic layer, which means that whenever your function is invoked, the New Relic agent included in the layer will instrument the function. After the agent generates the instrumented payload, `NR_LAMBDA_MONITORING`, the New Relic Lambda extension will send that data to New Relic. 

Depending on your needs, you can choose to either bypass the extension and only see telemetry in CloudWatch, bypass CloudWatch, or use CloudWatch as a fallback. The end of this doc will guide you through each option.

<CollapserGroup>
<Collapser
    id="cli"
    title="New Relic CLI"
>
You can instrument your Lambda function with the `newrelic-lambda` CLI quickstart. The CLI tool that we recommended for setting up the account link can also reconfigure your Lambda functions to use New Relic.

To install or upgrade the New Relic instrumentation layer, run this command:

```shell
newrelic-lambda layers install --nr-account-id <a href="/docs/accounts/accounts-billing/account-setup/account-id">YOUR_NR_ACCOUNT_ID</a> --function my-function --upgrade
```

This command automatically finds the newest available layer for your Lambda's region and runtime.

This is a great way to quick-start instrumentation, and this tool can easily be integrated into your existing CI/CD processes. However, since it modifies existing Lambda function resources, when you deploy a code update to your function, you may inadvertently remove the New Relic instrumentation. Be sure to re-run the command above after every update, or (even better) integrate the layer and associated configuration with your existing deployment process.

Note that the CLI can operate on many functions in a batch: use `--function all`, `--function installed`, or
`--function not-installed` to operate on all functions in a region, or only those with or without existing
New Relic instrumentation.

</Collapser>

  <Collapser
    id="cloudformation"
    title="CloudFormation / SAM templates"
  >
AWS's Serverless Application Model, or SAM is a variant of CloudFormation templates that simplifies relating functions to the resources they depend on, and managing the lifecycle of an entire application. We use SAM and CloudFormation for most of our Lambda example functions, and many other tools are built on top of CloudFormation templates, providing an addition layer of abstraction.

At its core, CloudFormation is a way to express the target state of an AWS Resource (such as a Lambda function) using YAML or JSON, and an execution service that makes API calls to other services (such as AWS Lambda) to achieve that target state.

Here's an example of a simple CloudFormation template for a Node.js Lambda function:

    ```yaml
    AWSTemplateFormatVersion: '2010-09-09'
    Transform: AWS::Serverless-2016-10-31
    Description: And example of a simple instrumented Node.js Lambda

    Resources:
      NewRelicExample:
        Type: AWS::Serverless::Function
        Properties:
          # In this example, we're using the SAM CLI to package and deploy our lambda. SAM will transform this value during the publish step.
          CodeUri: newrelic-example-node/
          # The handler for your function needs to be the one provided by the instrumentation layer, below.
          Handler: newrelic-lambda-wrapper.handler
          Runtime: nodejs12.x
          Environment:
            Variables:
              # For the instrumentation handler to invoke your real handler, we need this value
              NEW_RELIC_LAMBDA_HANDLER: YOUR_PATH_TO_INITIAL_LAMBDA_HANDLER
              # Distributed tracing needs your account ID, and your trusted account ID
              NEW_RELIC_ACCOUNT_ID: YOUR_ACCOUNT_ID_HERE
              # If your New Relic account has a parent account, this value should be that account ID. Otherwise, just
              # your account id.
              NEW_RELIC_TRUSTED_ACCOUNT_KEY: YOUR_PARENT_ACCOUNT_ID_HERE
          Layers:
            # This layer includes the New Relic Lambda extension, a sidecar process that sends telemetry,
            # as well as the New Relic agent for Node.js, and a handler wrapper that makes integration easy.
            - !Sub arn:${AWS::Partition}:lambda:${AWS::Region}:451483290750:layer:NewRelicNodeJS12X:34
          Policies:
            # This policy allows the lambda to know the value of the New Relic license key. We need this so
            # that we can send telemetry back to New Relic
            - AWSSecretsManagerGetSecretValuePolicy:
                SecretArn: !ImportValue NewRelicLicenseKeySecret-NewRelic-LicenseKeySecretARN
    ```

    Conventionally, you'll have a file named `template.yaml` that describes your function, and its resources.
  </Collapser>

  <Collapser
    id="serverless"
    title="Serverless Framework"
  >
Serverless Framework is a popular development and deployment tool for serverless applications. It's written for AWS in Node.js, and acts mostly as a higher-level abstraction on top of CloudFormation templates. It works well for Node, Python, Ruby, Java, and .NET functions.

New Relic offers a [Serverless Framework Plugin](https://github.com/newrelic/serverless-newrelic-lambda-layers) to simplify instrumentation of your Serverless Framework application.

To install the plugin, run this command:

```bash
    npm install --save-dev serverless-newrelic-lambda-layers
```

Or, alternatively,

```bash
    yarn add --dev serverless-newrelic-lambda-layers
```

Find your [New Relic Account ID](/docs/accounts/install-new-relic/account-setup/account-id), your [New Relic Personal API Key](/docs/apis/get-started/intro-apis/types-new-relic-api-keys#personal-api-key)

Then add the following to your `serverless.yaml` file:

```yaml
    plugins:
      - serverless-newrelic-lambda-layers
    custom:
      newRelic:
        accountId: your-new-relic-account-id-here
        apiKey: your-new-relic-personal-api-key-here
        linkedAccount: your-new-relic-integration-account-name-here
    ```
  </Collapser>

  <Collapser
    id="terraform"
    title="Terraform"
  >
    Terraform is a popular general-purpose infrastructure as code tool. It can be used to manage AWS resources, as
    well as many other things. We offer
    [some examples](https://github.com/newrelic/newrelic-lambda-extension/tree/main/examples/terraform) of New Relic
    instrumented Lambda functions deployed using Terraform scripts.
  </Collapser>

  <Collapser
    id="console"
    title="AWS manual instrumentation"
  >


While it is more error prone and labor intensive than the approaches above, it's possible to manually alter the configuration of a Lambda function to use New Relic from the AWS Lambda Console, for Node.js, Python, Ruby and Java.

Here's an example for how to instrument New Relic Lambda monitoring for a Ruby runtime:
    1. Navigate to the **Lambda** service section in the AWS web console. From there, find the Lambda function you would like to connect to New Relic.
    2. In the default **Code** tab, scroll down to the **Layers** section, and click on the **Add a layer** button.
    3. Click the **Create layer** button.
    4. Go to the **Choose a layer** and select the **Specify an ARN** option.
    5. Go to [New Relic's list of layers](https://layers.newrelic-external.com/) and use the drop-down list to select the AWS region where your Lambda function is hosted. From there, locate the ARN that matches your Lambda function's Ruby version and architecture. There should be two options: X86 and ARM64. Use the **Copy to clipboard** button or manually copy the ARN string.
    6. In the **Specify an ARN** section of the AWS console form, paste in the New Relic Lambda layer ARN.
    7. On the AWS console form, click the **Add** button to add the layer to your Lambda function.
    8. On your Lambda function's page, with the default **Code** tab selected, scroll down to the **Runtime settings** section and click the **Edit** button.
    9. Make a safe copy of the existing **Handler** value. You'll need it for a later step.
    10. Change the **Handler** value to: `newrelic_lambda_wrapper.handler` and click **Save**.
    11. Switch to the **Configuration** tab on your Lambda function's page.
    12. Select the **Environment variables** sub-tab.
    13. Define the following environment variables:
        * `NEW_RELIC_ACCOUNT_ID`: Set to your New Relic [account ID](/docs/accounts/install-new-relic/account-setup/account-id).
        * `NEW_RELIC_LAMBDA_HANDLER`: Set to your function's original Handler value copied down earlier.
            * `NEW_RELIC_LICENSE_KEY`: Set to your New Relic license key.
            * `NEW_RELIC_LOG_ENDPOINT`: Set to https://log-api.newrelic.com/log/v1.
            * `NEW_RELIC_TELEMETRY_ENDPOINT`: Set to https://cloud-collector.newrelic.com/aws/lambda/v1.
    14. If you want to send your Lambda function's logs to New Relic, which will include everything your function writes to STDOUT, make sure you set the `NEW_RELIC_EXTENSION_SEND_FUNCTION_LOGS` environment variable to `true`.
    15. Modify the Execution Role to allow access to the New Relic license key secret.
        * Find the ARN of the secret named `NEW_RELIC_LICENSE_KEY`.
        * Add a new inline policy in the function's execution role that looks like this the code below. Replace the `SECRET_ARN` with the value you found above.
            ```json
            "Statement": [
              {
                "Action": [
                  "secretsmanager:GetSecretValue"
                ],
                "Resource": "SECRET_ARN",
                "Effect": "Allow"
              }
            ]
            ```
    <Callout variant="tip">
    The New Relic layer will automatically deliver the New Relic Ruby agent and be loaded via a Ruby `require` prior to your Lambda function's invocation. To avoid conflicts, don't include a copy of the Ruby agent anywhere else. Feel free to perform any desired New Relic Ruby agent API calls within your function to take advantage of the agent's presence.
    </Callout>

Java, Python, Node.js, and .Net runtimes will follow the same instrumentation flow as Ruby, but with some different handlers. Here's how to update your function's handler to point to the newly attached layer in the console for your function:
        * Java:
            * `RequestHandler` implementation: `com.newrelic.java.HandlerWrapper::handleRequest`
            * `RequestStreamHandlerWrapper` implementation: `com.newrelic.java.HandlerWrapper::handleStreamsRequest`
        * Python and Ruby: `newrelic_lambda_wrapper.handler` (underscores)
        * Node: `newrelic-lambda-wrapper.handler` (hyphens)
        * For .Net you don't have to set the handler. 

Note that for Go, you must make source code changes to your Lambda function to instrument it. Configuration changes are not enough.
</Collapser>
</CollapserGroup>

## Shipping methods

<CollapserGroup>
<Collapser
    id="extension"
    title="Instrument with the extension only"
>

Every agent layer also contains an extension for sending logs and payloads to New Relic, bypassing CloudWatch. This can help reduce latency and costs as compared to CloudWatch. However, it comes at the risk of performance and reliability impacts to your function.

After adding a New Relic Lambda layer, the extension is enabled and has log shipping disabled by default.

If you want to see function logs in New Relic, you'll need to enable extension sending of function logs with an environment variable.

It's important to note that function logs are just the logs recorded by the function during its invocation. The extension will not send Lambda runtime logs like START, END, and REPORT lines.

</Collapser>

 <Collapser
    id="CloudWatch-only"
    title="Instrument with CloudWatch only"
  >

As [mentioned previously](/docs/serverless-function-monitoring/aws-lambda-monitoring/get-started/architecture#cloudwatch)
we used to recommend sending your telemetry through CloudWatch Logs. 

1. Disable the extension by adding the `NEW_RELIC_LAMBDA_EXTENSION_ENABLED` environment variable to your function, with the value `false`.
2. Create a CloudWatch Logs subscription filter, to invoke the `newrelic-log-ingestion` function with the logs for your function.
   * The CLI can do this for you: `newrelic-lambda subscriptions install --function FUNCTION_NAME`
   * Alternatively, use the AWS console to create a subscription filter from your function's CloudWatch Log Group to invoke the `newrelic-log-ingestion` lambda function. 

For a manual process, follow these steps to stream CloudWatch logs to New Relic Lambda:

    1. Open CloudWatch and select <DNT>**Logs**</DNT> in the left-hand menu, and then select the log group for the function you are monitoring.
    2. Select <DNT>**Actions > Subscription filters > Create Lambda subscription filter**</DNT>.
    3. Under <DNT>**Lambda function**</DNT>, select the `newrelic-log-ingestion` function.
    4. Set the <DNT>**Log format**</DNT> to `JSON`.
    5. Set the <DNT>**Subscription filter pattern to**</DNT> `?REPORT ?NR_LAMBDA_MONITORING ?"Task timed out" ?RequestId`. Alternatively, if you're using the `LOGGING_ENABLED` environment variable [stream all your logs](#stream-all-logs) to our Logs, leave this field blank.

       See [notes and caveats about this procedure](#stream-logs).

       <Callout variant="important">
         Make sure the `newrelic-log-ingestion` Lambda function you select in the method above is in the same AWS region as your Lambda function.
       </Callout>

</Collapser>

 <Collapser
    id="fallback"
    title="CloudWatch fallback"
  >

To learn more about our CloudWatch fallback, please see our [CloudWatch fallback documentation](/docs/serverless-function-monitoring/aws-lambda-monitoring/instrument-lambda-function/cloudwatch-fallback). 

</Collapser>
</CollapserGroup>

## What's next? [#find-data]

After you complete these steps, you can see data reporting in the [Lambda monitoring UI](/docs/lambda-monitoring-ui). If you're having trouble finding your data, see [Lambda enable troubleshooting](/docs/serverless-function-monitoring/aws-lambda-monitoring/instrument-lambda-function/introduction-lambda#troubleshoot).
