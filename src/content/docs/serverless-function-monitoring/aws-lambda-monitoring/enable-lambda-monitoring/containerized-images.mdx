---
title: Instrument your containerized function
metaDescription: A guide for instrumenting your containerized image layer with New Relic.
redirects:
        - /docs/serverless-function-monitoring/aws-lambda-monitoring/enable-containerized-function-monitoring/get-started/
freshnessValidatedDate: never
---

import serverlessContainerizedImagesWithLambda from 'images/serverless_diagram_containerized-images-with-lambda.webp'

If you're using a containerized image for a Lambda function and want to monitor your application, you'll need to add New Relic to your Dockerfile. For example, suppose you're a developer for a budgeting application and you're using a Lambda function to calculate account balances every time a customer clicks **See my balance**. You want to dive deep into any potential latencies. In that case, you'll need to add New Relic to your function, so every time a customer clicks **See my balance** your function runs, and New Relic does too.

First, you have to add a reference to New Relic's prebuilt layer to your Dockerfile. From there, you'll need to create a new image. After you've created a new image with the reference to New Relic merged with your original Dockerfile, you'll push the image to your [AWS Elastic Container Registry](https://console.aws.amazon.com/ecr/home/). Now, you'll need to create a _new function_ from the image you pushed to AWS ECR.

To understand how our prebuilt layer works, take a look at this diagram. 

<img
    title="containerized images "
    alt="A diagram demonstrating how New Relic integrates with your Lambda containerized image."
    src={serverlessContainerizedImagesWithLambda}
/>

<figcaption>
If you're using a containerized image for your Lambda function you can add New Relic to your image.
</figcaption>

Here's a guide to adding our pre-built layer to your code. 

<Steps>
<Step>
### Add New Relic to your Dockerfile
New Relic offers pre-built images that include our layer's different runtimes: Java, Node.js, Python, and extension-only.

1. Select the layer compatible with your specific Lambda function's runtime and region:
    * [Java](https://gallery.ecr.aws/newrelic-lambda-layers-for-docker/newrelic-lambda-layers-java)
    * [Node.js](https://gallery.ecr.aws/newrelic-lambda-layers-for-docker/newrelic-lambda-layers-nodejs) 
    * [Python](https://gallery.ecr.aws/x6n7b2o2/newrelic-lambda-layers-python)
    * [Ruby](https://gallery.ecr.aws/x6n7b2o2/newrelic-lambda-layers-ruby)
    * [Extension-only](https://gallery.ecr.aws/newrelic-lambda-layers-for-docker/newrelic-lambda-layers-lambdaextension)
1. In your Dockerfile, below your base image, add the following code: 

<Tabs>
    <TabsBar>
        <TabsBarItem id="java">Java</TabsBarItem>
        <TabsBarItem id="python">Python</TabsBarItem>
        <TabsBarItem id="nodejs">Node.js</TabsBarItem>
        <TabsBarItem id="ruby">Ruby</TabsBarItem>
        <TabsBarItem id="extension"> Extension-only</TabsBarItem>
    </TabsBar>

    <TabsPages>
        <TabsPageItem id="java">

                ```dockerfile
                FROM public.ecr.aws/newrelic-lambda-layers-for-docker/newrelic-lambda-layers-java:17-arm64 AS layer

                # Layer code
                COPY --from=layer /opt/ /opt/
                ```
        </TabsPageItem>

        <TabsPageItem id="python">

                ```dockerfile
                FROM public.ecr.aws/newrelic-lambda-layers-for-docker/newrelic-lambda-layers-python:38-arm64 AS layer

                # Layer code
                COPY --from=layer /opt/ /opt/
                ```
        </TabsPageItem>

        <TabsPageItem id="nodejs">

                ```dockerfile
                FROM public.ecr.aws/newrelic-lambda-layers-for-docker/newrelic-lambda-layers-nodejs:20-arm64 AS layer

                # Layer code
                COPY --from=layer /opt/ /opt/
                ```
        </TabsPageItem>

        <TabsPageItem id="Ruby">

                ```dockerfile

                FROM public.ecr.aws/newrelic-lambda-layers-for-docker/newrelic-lambda-layers-ruby:32-arm64 AS layer

                # Layer code
                COPY --from=layer /opt/ /opt/
                ```
        </TabsPageItem>

        <TabsPageItem id="extension">

                ```dockerfile
                FROM public.ecr.aws/newrelic-lambda-layers-for-docker/newrelic-lambda-layers-lambdaextension:x86 as layer

                # Layer code
                COPY --from=layer /opt/ /opt/
                ```
        </TabsPageItem>
    </TabsPages>
</Tabs>

### Example

Here is an example of the original Dockerfile merged with New Relic's prebuilt layer:

```dockerfile

# Define the New Relic pre-built image
FROM public.ecr.aws/newrelic-lambda-layers-for-docker/newrelic-lambda-layers-nodejs:20 AS layer

# Define the base image
FROM public.ecr.aws/lambda/nodejs:20

# Layer code
COPY --from=layer /opt/ /opt/

# Copy the function code and package.json
COPY index.js package.json ./

# Install any additional dependencies
RUN npm install

# Set the CMD to your handler
CMD [ "index.handler" ]
```

</Step>
<Step>

### Create an image
        1. After you add the reference to New Relic's pre-built image to your Dockerfile, you'll need to build a new image from the modified Dockerfile. This new image will have your original code _and_ New Relic's pre-built image. To do this, we recommend following the steps listed in the AWS guide, [Pushing a Docker image](https://docs.aws.amazon.com/lambda/latest/dg/images-create.html).
        2. Push the new image to your [AWS Elastic Container Registry](https://docs.aws.amazon.com/AmazonECR/latest/userguide/docker-push-ecr-image.html) repository for deployment.
</Step>

<Step>
### Configure your Lambda function
        1. Create a new Lambda function using the image you pushed to AWS ECR. For more information on creating this function, we recommend reviewing the AWS guide: [Working with container images](https://docs.aws.amazon.com/AmazonECR/latest/userguide/docker-push-ecr-image.html).
        2. Configure the Lambda function with the same settings as your original function, but ensure you add any required environment variables for New Relic Lambda monitoring. See our [Environment variables](/docs/serverless-function-monitoring/aws-lambda-monitoring/enable-lambda-monitoring/configure-serverless-monitoring-aws-lambda/#environment) for more information.
        3. Update your function's handler to point to the newly attached layer in `cmd` override for your function. You can do that using the instructions in these two docs:
                * [Lambda console UI configuration](/docs/serverless-function-monitoring/aws-lambda-monitoring/enable-lambda-monitoring/instrument-your-own/#console)
                * [Layerless instrumentation for Lambda monitoring](/docs/serverless-function-monitoring/aws-lambda-monitoring/enable-lambda-monitoring/enable-serverless-monitoring-aws-lambda-layerless)
</Step>
</Steps>

