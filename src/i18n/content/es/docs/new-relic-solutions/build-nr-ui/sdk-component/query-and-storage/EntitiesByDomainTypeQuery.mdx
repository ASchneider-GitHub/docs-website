---
title: Entidades por consulta de tipo de dominio
metaDescription: Learn how to work the EntitiesByDomainTypeQuery component
freshnessValidatedDate: '2024-06-03T00:00:00.000Z'
translationType: machine
---

consulta entidad por dominio de entidad y tipo de entidad.

### Uso

```js
import { EntitiesByDomainTypeQuery } from 'nr1'
```

### Ejemplos

#### consulta declarativa

```js
<EntitiesByDomainTypeQuery entityDomain="APM" entityType="APPLICATION">
  {({ error, data, fetchMore }) => {
    if (error) {
      return 'Error!';
    }


    return (
      <List
        items={data.entities}
        rowCount={data.count}
        rowHeight={20}
        onLoadMore={fetchMore}
      >
        {({ item }) => <ListItem key={item.guid}>{item.name}</ListItem>}
      </List>
    );
  }}
</EntitiesByDomainTypeQuery>
```

#### Obtener con criterios de clasificación

```js
<EntitiesByDomainTypeQuery
  entityDomain="INFRA"
  entityType="HOST"
  sortBy={[EntitiesByDomainTypeQuery.SORT_TYPE.ALERT_SEVERITY]}
>
  {({ data, error, fetchMore }) => {
    if (error) {
      return 'Error!';
    }


    return (
      <List
        items={data.entities}
        rowCount={data.count}
        rowHeight={20}
        onLoadMore={fetchMore}
      >
        {({ item }) => <ListItem key={item.guid}>{item.name}</ListItem>}
      </List>
    );
  }}
</EntitiesByDomainTypeQuery>
```

#### consulta imperativa

```js
EntitiesByDomainTypeQuery.query({
  entityDomain: 'APM',
  entityType: 'APPLICATION',
}).then(({ data }) => console.log(data));
```

#### Obtener más resultados mediante consulta imperativa

```js
const firstPage = await EntitiesByDomainTypeQuery.query({
  entityDomain: 'APM',
  entityType: 'APPLICATION',
});


console.log('First page data', firstPage.data);


const cursor = firstPage.data.nextCursor;
const secondPage = await EntitiesByDomainTypeQuery.query({
  cursor,
  entityDomain: 'APM',
  entityType: 'APPLICATION',
});


console.log('Second page data', secondPage.data);


// NOTE: To fetch multiple page results consecutively,
// use EntitiesByDomainTypeQuery component's fetchMore approach.
```

### Props

<table>
  <tbody>
    <tr>
      <td>
        `children` <h5>función</h5>
      </td>

      <td>
        Representar la función de utilería como niño.

        <FunctionDefinition
          returnValue={[{"type":"React.ReactNode","description":""}]}
          arguments={[{"name":"queryResult","type":"QueryResult","description":"Results of the query."}]}
        />
      </td>
    </tr>

    <tr>
      <td>
        `entityDomain` <h5>cadena</h5><h5>REQUERIDA</h5>
      </td>

      <td>
        dominio de la entidad que desea consultar.
      </td>
    </tr>

    <tr>
      <td>
        `entityFragmentExtension` <h5>objeto</h5>
      </td>

      <td>
        Documento de fragmento GraphQL analizado en un AST por `graphql-tag`. Los componentes de consulta devuelven los campos más empleados disponibles en una entidad. Puede emplear este accesorio cuando desee aplicar campos adicionales para la entidad devuelta por su consulta. El fragmento debe llamar `EntityFragmentExtension` y aplicar al tipo `EntityOutline` .

        ```js
        const entityFragmentExtension = ngql`
          fragment EntityFragmentExtension on EntityOutline {
            indexedAt
            guid
          }
        `;
        ```
      </td>
    </tr>

    <tr>
      <td>
        `entityType` <h5>cadena</h5><h5>REQUERIDA</h5>
      </td>

      <td>
        Tipo de entidad que desea consultar.
      </td>
    </tr>

    <tr>
      <td>
        `fetchPolicyType` <h5>enumeración</h5>
      </td>

      <td>
        Le permite especificar cómo desea que su consulta interactúe con los datos almacenados en caché.

        * `CACHE_AND_NETWORK`: La consulta devuelve sus datos iniciales del caché si están disponibles. Sin embargo, independientemente de si los datos completos están en su caché o no, la consulta siempre realiza una solicitud empleando su interfaz de red y devuelve los datos actualizados. Esta opción no está disponible cuando se emplea el método estático `query()` del componente.

        * `CACHE_FIRST`: La consulta realiza una solicitud empleando su interfaz de red **solo** si los datos de su consulta aún no están en el caché.

        * `CACHE_ONLY`: La consulta **nunca** realiza una solicitud empleando su interfaz de red. En lugar de eso, devuelve los datos disponibles en el caché. Si los datos de su consulta no existen en la memoria caché, se genera un error.

        * `NETWORK_ONLY`: La consulta **nunca** devuelve los datos iniciales del caché. En lugar de eso, **siempre** realiza una solicitud empleando su interfaz de red.

        * `NO_CACHE`: La consulta **nunca** devuelve los datos iniciales del caché. En lugar de eso, **siempre** realiza una solicitud empleando su interfaz de red. A diferencia de la política `NETWORK_ONLY` , no escribe ningún dato en la caché una vez completada la consulta.

          <OptionReference>
            EntitiesByDomainTypeQuery.FETCH_POLICY_TYPE.CACHE_AND_NETWORK, EntitiesByDomainTypeQuery.FETCH_POLICY_TYPE.CACHE_FIRST, EntitiesByDomainTypeQuery.FETCH_POLICY_TYPE.CACHE_ONLY, EntitiesByDomainTypeQuery.FETCH_POLICY_TYPE.NETWORK_ONLY, Consulta.FETCH_POLICY_TYPE.NO_CACHE,
          </OptionReference>
      </td>
    </tr>

    <tr>
      <td>
        `filters` <h5>cadena</h5>|(forma|forma|forma)\[]
      </td>

      <td>
        Filtros empleados para acotar la entidad. Esta es una matriz de filtros, y hay 3 filtros posibles:

        * Filtro de consulta de búsqueda: `Object<type: string = "searchQuery", value: string>`
        * Filtro de tipo de entidad: `Object<type: string = "entityType", Object<domain: string, type: string>>`
        * Filtro de etiquetas: `Object<type: string = "tag", Object<key: string, value: string>>`

        ```js
        const filters = [
          {
            type: 'searchQuery',
            value: 'foo',
          },
          {
            type: 'entityType',
            value: { domain: 'APM', type: 'APPLICATION' },
          },
          {
            type: 'tag',
            value: { key: 'environment', value: 'production' },
          },
          {
            type: 'tag',
            value: { key: 'team', value: 'bar' },
          },
        ];
        ```
      </td>
    </tr>

    <tr>
      <td>
        `includeSummaryMetrics` <h5>booleano</h5>
      </td>

      <td/>
    </tr>

    <tr>
      <td>
        `includeTags` <h5>booleano</h5>
      </td>

      <td>
        Si `true`, la entidad devuelta incluye su etiqueta.
      </td>
    </tr>

    <tr>
      <td>
        `limit` <h5>número</h5>
      </td>

      <td>
        Paginación, número de entidades a buscar en cada página.
      </td>
    </tr>

    <tr>
      <td>
        `pollInterval` <h5>número</h5>
      </td>

      <td>
        Intervalo en milisegundos para sondear nuevos datos. Establezca en cero para evitar cualquier tipo de sondeo regular.
      </td>
    </tr>

    <tr>
      <td>
        `skip` <h5>booleano</h5>
      </td>

      <td>
        Cuando se establece en `true`, la consulta se omitirá por completo del procesamiento.
      </td>
    </tr>

    <tr>
      <td>
        `sortBy` <h5>enum\[]</h5>
      </td>

      <td>
        Matriz de criterios empleados para ordenar los resultados de búsqueda de entidades.

        <OptionReference array>
          EntitiesByDomainTypeQuery.SORT_TYPE.alertas, EntitiesByDomainTypeQuery.SORT_TYPE.dominio, EntitiesByDomainTypeQuery.SORT_TYPE.MOST_RELEVANT, EntitiesByDomainTypeQuery.SORT_TYPE.NAME, EntitiesByDomainTypeQuery.SORT_TYPE.REPORTING, educación física,
        </OptionReference>
      </td>
    </tr>
  </tbody>
</table>

### Métodos

### `EntitiesByDomainTypeQuery.query`

<FunctionDefinition
  arguments={[{"description":"Object containing the query options. Any `EntitiesByDomainTypeQuery` prop is a valid option except `children` and `pollInterval`.","name":"props","type":"Object"}]}
  returnValue={{"description":"","type":"PromiseQueryResult"}}
/>

### Definiciones de tipos

<TypeDefReference typeDef={{"name":"PromiseQueryResult","properties":[{"description":"Runtime error with `graphQLErrors` and `networkError` properties.","name":"error","type":"ApolloClient.ApolloError"},{"description":"Object containing the result of your query.","name":"data","type":"Object"},{"description":"If not `null`, `fetchMore` allows you to load more results for your query. New data is merged with previous data.","name":"fetchMore","type":"function|null"},{"description":"Refetch the query.","name":"refetch","type":"function"}]}}/>

<TypeDefReference typeDef={{"name":"QueryResult","properties":[{"description":"Indicates that the request is in flight.","name":"loading","type":"boolean"},{"description":"Runtime error with `graphQLErrors` and `networkError` properties.","name":"error","type":"ApolloClient.ApolloError"},{"description":"Object containing the result of your query.","name":"data","type":"Object"},{"description":"If not `null`, `fetchMore` allows you to load more results for your query. New data is merged with previous data.","name":"fetchMore","type":"function|null"},{"description":"Refetch the query.","name":"refetch","type":"function"}]}}/>