---
title: Lista
metaDescription: Learn how to work the List component
freshnessValidatedDate: '2024-06-03T00:00:00.000Z'
translationType: machine
---

`<List>` le permite renderizar eficientemente una gran lista de elementos.

El `<List>` puede representar los elementos de dos maneras: como una matriz de elementos `<ListItem>` o como una devolución de llamada de procesamiento (Función como hijos). Se recomienda emplear la devolución de llamada de renderizado, ya que virtualizará todos los elementos, lo que lo hará muy rápido cuando se proporcione una gran cantidad de elementos.

Si el ancho y el alto no se especifican a través de los accesorios `style` o `className` , llenará el alto y el ancho del contenedor, a menos que se proporcione `width="fit-content"` como accesorio. Luego, dimensionará el contenedor `<List>` para que sea tan ancho como el componente `<ListItem>` medido más ancho.

### Uso

```js
import { List } from 'nr1'
```

### Ejemplos

#### Básico

```js
function render() {
  return (
    <List rowHeight={20}>
      <ListItem>Item 1</ListItem>
      <ListItem>Item 2</ListItem>
      <ListItem>Item 3</ListItem>
      <ListItem>Item 4</ListItem>
    </List>
  );
}
```

#### Renderizar devolución de llamada

```js
function render() {
  const items = new Array(10000).fill().map((_, i) => {
    return { key: `foo-${i}`, name: `Item ${i}` };
  });


  const style = { width: 200, height: 300 };


  return (
    <List style={style} rowHeight={20} items={items}>
      {({ item }) => <ListItem key={item.key}>{item.name}</ListItem>}
    </List>
  );
}
```

#### Carga lenta

```js
function render() {
  // This example assumes you have a way to know/load this information.
  const remoteTotalNumberOfItems = 9000;


  const items = [
    { id: 1, text: 'Item 1' },
    { id: 2, text: 'Item 2' },
    { id: 3, text: 'Item 3' },
    { id: 4, text: 'Item 4' },
  ];


  function loadMoreItems({ startIndex, stopIndex }) {
    return fetch(`path/to/api?start=${startIndex}&stop=${stopIndex}`).then(
      () => {
        // Store items in list...
      },
    );
  }


  const style = { width: 200, height: 300 };


  return (
    <div style={style}>
      <List
        items={items}
        rowCount={remoteTotalNumberOfItems}
        onLoadMore={loadMoreItems}
      >
        {({ item }) => <ListItem key={item.id}>{item.text}</ListItem>}
      </List>
    </div>
  );
}
```

#### Tamaño automático al ancho del contenido

```js
class AutoSizingList extends React.Component {
  constructor() {
    super(...arguments);
    this.state = {
      items: this._generateItems(0),
    };
    this._maxItems = 1000;
    this._onLoadMore = this._onLoadMore.bind(this);
  }


  _onLoadMore(cursor) {
    return (
      Promise.resolve()
        // Fetch more items to load into <List>
        .then(() => this._generateItems(this.state.items.length))
        .then((moreItems) =>
          // Add retrieved items to the stored list
          this.setState(({ items }) => ({ items: items.concat(moreItems) })),
        )
    );
  }


  _generateString(num, extra = 0) {
    return `Entity ${num.toString(10)}: 1${'00'.repeat(
      Math.floor(Math.random() * 10) + 1 + extra,
    )} bytes`;
  }


  _generateItems(start) {
    return new Array(200).fill().map((_, i) => ({
      key: `foo-${start + i}`,
      name: this._generateString(start + i, start / 100),
    }));
  }


  render() {
    const style = { 'height': 300, 'background-color': 'white' };
    const parentStyle = { width: 260 };


    return (
      <div style={parentStyle}>
        <List
          rowCount={this._maxItems}
          onLoadMore={this._onLoadMore}
          style={{ ...style }}
          rowHeight={20}
          items={this.state.items}
          width="fit-content"
        >
          {({ item }) => <ListItem key={item.key}>{item.name}</ListItem>}
        </List>
      </div>
    );
  }
}
```

#### integración con componentes de consulta

```js
function render() {
  const style = { width: 200, height: 300 };


  const list = (
    <div style={style}>
      <EntitiesByDomainTypeQuery entityDomain="APM" entityType="APPLICATION">
        {({ fetchMore, loading, data }) => {
          const { results, count } = data.actor.entitySearch;


          return (
            <List
              rowHeight={40}
              items={results.entities}
              onLoadMore={fetchMore}
              rowCount={count}
            >
              {({ item }) => <ListItem key={item.id}>{item.text}</ListItem>}
            </List>
          );
        }}
      </EntitiesByDomainTypeQuery>
    </div>
  );
}
```

### Props

<table>
  <tbody>
    <tr>
      <td>
        `children` Nodo <h5>REQUERIDO</h5> <h5>|función</h5>
      </td>

      <td>
        Puede ser una matriz de `<ListItem>` elementos o una devolución de llamada de renderizado (función como elementos secundarios). La recomendación es emplear la devolución de llamada de renderizado, ya que virtualizará todos los elementos, lo que lo hace muy rápido cuando se proporciona una gran cantidad de elementos. Cuando se emplea la devolución de llamada de renderizado, los elementos deben proporcionar a través del accesorio `items` .
      </td>
    </tr>

    <tr>
      <td>
        `className` <h5>cadena</h5>
      </td>

      <td>
        Nombre de clase para estilo personalizado.
      </td>
    </tr>

    <tr>
      <td>
        `fullHeight` <h5>booleano</h5>
      </td>

      <td>
        Expande la stack para ocupar toda la altura disponible.
      </td>
    </tr>

    <tr>
      <td>
        `fullWidth` <h5>booleano</h5>
      </td>

      <td>
        Expande la stack para ocupar todo el ancho disponible.
      </td>
    </tr>

    <tr>
      <td>
        `items` <h5>cualquier\[]</h5>
      </td>

      <td>
        Los elementos que se emplearán al renderizar. Son necesarios al renderizar elementos con una devolución de llamada de renderizado. Cada elemento puede tener cualquier estructura y tipo posible, y se proporcionará el correspondiente al renderizar cada lista de elementos.

        ```js
        function render() {
          const style = { width: 200, height: 300 };

          const items = [
            { foo: 'a', bar: 'x' },
            { foo: 'b', bar: 'y' },
          ];

          return (
            <div style={style}>
              <List items={items}>
                {({ item, index }) => (
                  <ListItem key={index}>{`${item.foo} - ${item.bar}`}</ListItem>
                )}
              </List>
            </div>
          );
        }
        ```
      </td>
    </tr>

    <tr>
      <td>
        `onLoadMore` <h5>función</h5>
      </td>

      <td>
        La devolución de llamada se activa cuando se deben cargar más artículos. Esto sucede cuando carga los elementos de forma diferida y los elementos que están a punto de renderizarse no se pueden encontrar en la matriz `items` . Esta devolución de llamada debe usar para recuperar/cargar los elementos que faltan desde el backend u otras fuentes. La promesa devuelta debe resolver una vez que los datos del elemento terminaron de cargar. Se empleará para determinar cuándo actualizar la lista con los datos recién cargados. Esta devolución de llamada se puede llamar varias veces como reacción a un único evento de desplazamiento.

        <FunctionDefinition
          returnValue={[]}
          arguments={[{"name":"cursor","type":"Cursor","description":"Items to load."}]}
        />
      </td>
    </tr>

    <tr>
      <td>
        `rowCount` <h5>número</h5>
      </td>

      <td>
        Número de filas. De forma predeterminada, es igual a la longitud de la matriz pasada en la propiedad de elementos. Debe especificar `rowCount` cuando conozca el número total de elementos pero desee cargarlos de forma diferida mientras se desplaza.
      </td>
    </tr>

    <tr>
      <td>
        `rowHeight` <h5>Numero</h5> <h5>requerido</h5>
      </td>

      <td>
        Altura de la fila de la lista. Requerido al renderizar elementos con la devolución de llamada de renderizado (Función como hijos). Esta es una altura provisional hasta que se mida el contenido de la celda representándolo temporalmente de una manera que no sea visible para el usuario.
      </td>
    </tr>

    <tr>
      <td>
        `spacingType` <h5>enum\[]</h5>
      </td>

      <td>
        Propiedad de espaciado. El espaciado se define como una tupla de cero a cuatro valores, que siguen las mismas convenciones que las propiedades CSS como `margin` o `padding`. Para omitir un valor, use `SPACING_TYPE.OMIT`.

        <OptionReference array>
          Lista.SPACING_TYPE.EXTRA_LARGE, Lista.SPACING_TYPE.LARGE, Lista.SPACING_TYPE.MEDIUM, Lista.SPACING_TYPE.NONE, Lista.SPACING_TYPE.OMIT, Lista.SPACING_TYPE.SMALL,
        </OptionReference>
      </td>
    </tr>

    <tr>
      <td>
        `style` <h5>objeto</h5>
      </td>

      <td>
        Estilo en línea para un estilo personalizado.
      </td>
    </tr>

    <tr>
      <td>
        `testId` <h5>cadena</h5>
      </td>

      <td>
        Agrega un atributo `data-test-id` . Úselo para apuntar al componente en pruebas unitarias y E2E. Para que una identificación de prueba sea válida, antepóngale su identificación de nerdpack, seguido de un punto. Por ejemplo, `my-nerdpack.some-element`.

        **Nota:** Es posible que no veas el atributo `data-test-id` ya que se eliminan del DOM. Para depurarlos, pasa un parámetro de consulta `e2e-test` a la URL.
      </td>
    </tr>

    <tr>
      <td>
        `width` <h5>cadena</h5>
      </td>

      <td>
        Representa el ancho de la lista. Siempre es una cadena y puede ser de uno de los siguientes tipos:

        * `'fit-content'`: habilita el tamaño automático del contenedor `<List>` . Diseñado para usar con `<List>`virtualizados para garantizar que el contenedor se ajuste al ancho del `<ListItem>` más ancho. Cambia de tamaño a medida que el componente `<List>` carga más elementos. No afecta la altura del componente `<List>` , que seguirá ajustar a la altura del contenedor en el que se encuentra el componente `<List>` .
        * `'auto'`: El valor predeterminado para `<List>`. Este símbolo cambia el tamaño del componente `<List>` según su estilo predeterminado, permitiéndole expandir para llenar el ancho y alto de su contenedor. Luego se ajusta el tamaño del contenido para que se ajuste al ancho resultante del componente `<List>` .
      </td>
    </tr>
  </tbody>
</table>

### Definiciones de tipos

<TypeDefReference typeDef={{"name":"RenderCallbackArguments","properties":[{"description":"Item to render.","name":"item","type":"any"},{"description":"Index of the item in the items array.","name":"index","type":"number"},{"description":"Array of items which we're iterating on.","name":"items","type":"any[]"}]}}/><TypeDefReference typeDef={{"name":"Cursor","properties":[{"description":"First index of the range of items to load.","name":"startIndex","type":"number"},{"description":"Last index of the range of items to load.","name":"stopIndex","type":"number"}]}}/>