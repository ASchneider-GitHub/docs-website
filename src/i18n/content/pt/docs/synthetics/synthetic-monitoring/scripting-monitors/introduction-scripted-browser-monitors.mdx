---
title: Introdução ao monitor do browser com script
tags:
  - Synthetics
  - Synthetic monitoring
  - Scripting monitors
metaDescription: 'How to create scripted browsers, which send Selenium browsers to your website to test key workflows such as login or search.'
freshnessValidatedDate: never
translationType: machine
---

import syntheticCreate from 'images/synthetic_screenshot-crop_create-monitor.webp'

import syntheticUserFlowFunctionality from 'images/synthetic_screenshot-full_user-flow-functionality.webp'

import syntheticConfigureMonitor from 'images/synthetic_screenshot-crop_configure-monitor.webp'

import syntheticSelectLocations from 'images/synthetic_screenshot-crop_select-locations.webp'

Scripted browsers emulate a custom user experience by scripting browsers that navigate your website, take specific actions, and ensure specific elements are present. [Selenium WebDriver](https://www.selenium.dev/documentation/webdriver/) drives scripted monitors. Each time your script runs, New Relic creates a fully virtualized Selenium-driven Google Chrome browser that navigates your website and follows each script step. Synthetic monitoring includes an IDE-style script editor that suggests functions, locators, and other elements to simplify scripting. See [Scripted browser reference](/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetic-scripted-browser-reference-monitor-versions-chrome-100/) for a list of all available functions.

## How to create a scripted browser monitor [#create-scripted-browser]

1. Vá para <DoNotTranslate>**[one.newrelic.com > All capabilities](https://one.newrelic.com/all-capabilities) > Synthetic monitoring**</DoNotTranslate>.

2. Clique em <DoNotTranslate>**Create monitor**</DoNotTranslate>.

3. Select the <DoNotTranslate>**User flow / functionality**</DoNotTranslate> tile to test the availability and functionality of your site in different locations.

   <img
     title="Create monitor - User flow / functionality"
     alt="Create monitor - User flow / functionality"
     src={syntheticUserFlowFunctionality}
   />

4. Configure the monitor. Fill in the fields you want. Add a name for your monitor.

   <img
     title="Create monitor - configure monitor"
     alt="Create monitor - configure monitor"
     src={syntheticConfigureMonitor}
   />

5. Click <DoNotTranslate>**Select locations**</DoNotTranslate> to select the location you want to test the monitor.

   <img
     title="Create monitor - select locations"
     alt="Create monitor - select locations"
     src={syntheticSelectLocations}
   />

6. Click <DoNotTranslate>**Write script**</DoNotTranslate> to add your script describing the actions you want the monitor to take. The monitor pre-fills the editor with an example script you can work from, or you can remove this and start from scratch.

7. Click <DoNotTranslate>**Validate**</DoNotTranslate> if you want to test your script. This may take a few minutes depending on the script.

8. Clique em <DoNotTranslate>**Save monitor**</DoNotTranslate>.

## Visite um URL [#visiting-a-url]

Todos os scripts começam especificando para qual URL o monitor deve navegar. Para especificar um URL, chame `$webDriver.get("url")`:

```js
await $webDriver.get("https://mywebsite.com");
```

## Sequenciar ações [#sequence]

Because WebDriverJS is asynchronous, scripting actions can sometimes execute out of order. To force script actions to execute in order, use the `await` keyword:

```js
await $webDriver.get("https://my-website.com");
await $webDriver.findElement($selenium.By.linkText("Configuration Panel"));
```

You can also wrap each action in a `then(function(){})` call. But, in that case, the wrapped function must `return` each asynchronous function to ensure they complete before the script moves on:

```js
$webDriver.get("https://my-website.com").then(function(){
    return $webDriver.findElement($selenium.By.linkText("Configuration Panel"));
});
```

Para conectar diversas ações em sequência, envolva cada ação em uma chamada `then(function(){})` e encadeie as chamadas:

```js
$webDriver.get("https://my-website.com").then(function(){
    return $webDriver.findElement($selenium.By.linkText("Configuration Panel"));
}).then(function(){
    return $webDriver.findElement($selenium.By.partialLinkText("Configuration Pa"));
});
```

## Localize elementos [#locating-elements]

Once you've specified a URL to monitor, you'll usually want to locate a particular element on the page. Locating an element verifies its presence on the page, and also allows you to [interact with page elements](#interacting-elements).

You can locate elements by their `class`, `id`, `link text`, `name` or even XPath. To find these attributes, use your browser's developer tools or view your website's source code. For a list of all locator functions, see [Locators: Find page elements](/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetic-scripted-browser-reference-monitor-versions-chrome-100/#locators).

<CollapserGroup>
  <Collapser
    id="locate-by-class"
    title="Localize por classe CSS"
  >
    Locate an element by its HTML `class`, for example `class="button"`. A class is usually specified for CSS styling. When locating an element by class, the monitor will select the first element on the page that has that class:

    ```js
    await $webDriver.findElement($selenium.By.className("button"));
    ```
  </Collapser>

  <Collapser
    id="locate-by-id"
    title="Localizar por ID HTML"
  >
    Locate an element by its exact HTML `id`, for example `id="edit-submit"`. This is a straightforward way to locate page elements, but be careful to specify an `id` that isn't likely to change.

    ```js
    await $webDriver.findElement($selenium.By.id("edit-submit"));
    ```

    For an example of locating an element by its `id`, see [Wait for a specific element](#wait-page-element) section.
  </Collapser>

  <Collapser
    id="locate-by-link-text"
    title="Localizar por texto vincular"
  >
    Locate an element by its displayed link text, for example `<a href="http://example.com>your link text here</a>`. You can locate by the exact link text `$selenium.By.linkText` or by partial match `$selenium.By.partialLinkText`:

    ```js
    await $webDriver.findElement($selenium.By.linkText("Configuration Panel"));
    ```

    ```js
    await $webDriver.findElement($selenium.By.partialLinkText("Configuration Pa"));
    ```
  </Collapser>

  <Collapser
    id="locate-by-name"
    title="Localizar por nome"
  >
    Locate an element by its exact HTML `name`, for example `name="search-query-field"`. This is most commonly used with input fields such as a search box:

    ```js
    await $webDriver.findElement($selenium.By.name("search-query-field"));
    ```

    For an example of locating an element by its `name`, see [Log in to a website](/docs/synthetics/synthetic-monitoring/getting-started/get-started-synthetic-monitoring/#login).
  </Collapser>

  <Collapser
    id="locate-by-xpath"
    title="Localizar por XPath"
  >
    Para estruturas de páginas mais complexas, você pode usar XPath para localizar o elemento alvo:

    ```js
    await $webDriver.findElement($selenium.By.xpath("//input[@placeholder = 'search-query-field']"));
    ```

    XPath selectors can break when your website's structure changes. For tips on building good XPath selectors, see [Optimizing XPath selectors](https://blog.newrelic.com/engineering/optimize-xpath-selectors/).

    <Callout variant="tip">
      To quickly find the XPath for a particular element, use your browser's developer tools. For example, from Chrome:

      1. Navigate to the target website from Chrome.

      2. Clique com o botão direito no elemento alvo e selecione

         <DoNotTranslate>**Inspect element**</DoNotTranslate>

         .

      3. No painel Developer Tools que abre automaticamente, procure o elemento alvo em destaque.

      4. Clique com o botão direito no elemento alvo e selecione

         <DoNotTranslate>**Copy XPath**</DoNotTranslate>

         .
    </Callout>
  </Collapser>
</CollapserGroup>

## Interaja com elementos [#interacting-elements]

Because a scripted monitor drives a real, Selenium-powered Google Chrome browser, scripted monitors can interact with page elements in the same way a user would. For example, the monitor can click a link, enter text in a search box, etc. For a list of available actions, see [ActionSequence: Link multiple actions](/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetic-scripted-browser-reference-monitor-versions-chrome-100/#actionsequence).

Primeiro, [localize o elemento de página](#locating-elements) e depois chame uma função de interação:

<CollapserGroup>
  <Collapser
    id="clicking-elements"
    title="Clique em elemento da página"
  >
    Para clicar em um link ou outro elemento da página, localize o elemento e chame a função `click()` :

    ```js
    await $webDriver.findElement($selenium.By.linkText("Configuration Panel")).click();
    ```

    ```js
    await $webDriver.findElement($selenium.By.className("config-panel-02")).click();
    ```

    For an example of clicking a located element, see [Locate by link text](#locate-by-link-text).

    <Callout variant="tip">
      Você pode controlar o mouse de outras maneiras com as funções `doubleClick()`, `dragAndDrop()`, `mouseDown`, `mouseUp` e `mouseMove` .
    </Callout>
  </Collapser>

  <Collapser
    id="entering-text"
    title="Insira o texto"
  >
    Para inserir texto em um campo, localize o campo e chame a função `sendKeys()` :

    ```js
    await $webDriver.findElement($selenium.By.name("search-query-field")).sendKeys("EXAMPLE USER NAME");
    ```

    ```js
    await $webDriver.findElement($selenium.By.id("search-q-box")).sendKeys("EXAMPLE USER NAME");
    ```

    Some fields may have default text in them. [Clear](/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetic-scripted-browser-reference-monitor-versions-chrome-100/#webelement) these fields before sending text to them:

    ```js
    await $webDriver.findElement($selenium.By.name("search-query-field")).clear();
    ```

    ```js
    await $webDriver.findElement($selenium.By.id("search-q-box")).clear();
    ```

    For an example of entering text in a field, see [Locate by link text](#locate-by-link-text).

    <Callout variant="tip">
      You can add modifier keys, such as `ALT` and `SHIFT` with the `keyDown()` and `keyUp()` functions.
    </Callout>
  </Collapser>
</CollapserGroup>

## Espera e tempos limite [#waiting-elements]

Large page elements, such as images or complex dynamic content, can take a long time to load. Your script may fail if the monitor tries to interact with or find an element that has not yet loaded.

To avoid these issues, set wait conditions that will pause the script until the specified page element is present, or [sequence actions manually](#sequence). For a list of conditions, see [Conditions: Pause and wait for conditions](/docs/synthetics/synthetic-monitoring/scripting-monitors/synthetic-scripted-browser-reference-monitor-versions-chrome-100/#until).

<Callout variant="important">
  Após um tempo de execução máximo de três minutos, o New Relic interrompe manualmente o script.
</Callout>

<CollapserGroup>
  <Collapser
    id="wait-page-title"
    title="Aguarde o título da página"
  >
    Instrua o monitor a aguardar que o título da página corresponda a um determinado valor. Isso garante que o browser recebeu pelo menos alguns dados da página de destino. Para aguardar o título da página, especifique um título esperado e um valor de tempo limite em milissegundos:

    ```js
    //Call the wait function
    await $webDriver.wait(async function() {
      //Tell the monitor to get the page title.
      var title = await $webDriver.getTitle();
      //Specify the expected page title.
      return title === "Your Page Title Here";
    //If the condition is not satisfied within a timeout of 1000 milliseconds (1 second), proceed anyway.
    }, 1000);
    ```

    For an example of waiting for page title, see [Wait for page title](#wait-page-title).
  </Collapser>

  <Collapser
    id="wait-page-element"
    title="Aguarde um elemento específico"
  >
    Instrua o monitor a aguardar a presença de um elemento da página. Isso é útil quando um elemento do qual seu script depende demora muito para carregar ou simplesmente para garantir que um elemento de página esteja presente antes que seu script clique nele.

    Use qualquer uma das [funções de localização](#locating-elements) com a função de espera abaixo. Use a função desejada em vez da função `$selenium.By.linkText` usada abaixo:

    ```js
    // Tell the monitor to wait up to 7,500 milliseconds (7.5 seconds) for a link whose text is `Your Link Text Here`.
    var linkText = "Your Link Text Here"

    var element = await $webDriver.wait(
      $selenium.until.elementLocated(
        $selenium.By.linkText(linkText),
      ),
      7500,
      'Timed-out waiting for element to be located using link text: "' +linkText+ '"',
    );
    // Wait for the element to be visible
    await $webDriver.wait(
      $selenium.until.elementIsVisible(element),
      7500,
      "Timed-out waiting for element to be visible using ${element}",
    );
    ```

    <Callout variant="important">
      `elementIsVisible()` não conseguirá encontrar um elemento se ele estiver totalmente atrás de outro elemento ou se tiver tamanho 0. Ele ainda encontrará elementos com opacidade 0.
    </Callout>
  </Collapser>
</CollapserGroup>

## Resultados do script de log [#logging]

Você também pode log manualmente os resultados do monitor no [logdo script](/docs/synthetics/synthetic-monitoring/using-monitors/view-simple-scripted-monitor-results/#viewing-logs). Use o log para solucionar problemas de um script: para descobrir qual etapa do seu script está falhando, inclua uma função de log junto com cada etapa principal do seu script.

<Callout variant="important">
  O comprimento máximo do log é de 50.000 bytes. O log de script com mais de 50.000 bytes é truncado.
</Callout>

<CollapserGroup>
  <Collapser
    id="log-static"
    title="Log texto estático"
  >
    Para log uma linha de texto estático, chame `console.log()`:

    ```js
    //Send `Hello world.` to the console log.
    console.log('Hello world.');
    ```

    Isso resulta [na saída](/docs/synthetics/synthetic-monitoring/using-monitors/view-simple-scripted-monitor-results/#viewing-logs):

    ```js
    // ----------------------------------- Console log
    Hello world.
    ```
  </Collapser>

  <Collapser
    id="pass-a-variable"
    title="Passe uma variável para a função log"
  >
    Além de [registrar texto estático](#log-static), você também pode passar variáveis para `console.log()`:

    ```js
    //Declare the variable `WEBSITE_URL`
    var assert = require('assert'),
      WEBSITE_URL = 'https://my-website.com/';

    console.log('Hello world.');
    //Load the website specified in `WEBSITE_URL`
    await $webDriver.get(WEBSITE_URL);
    //Log our success to the console
    console.log('Success for', WEBSITE_URL);
    ```

    [Procure estes resultados](/docs/synthetics/synthetic-monitoring/using-monitors/view-simple-scripted-monitor-results/#viewing-logs):

    ```js
    // ----------------------------------- Console log
    Hello world.
    Success for https://my-website.com/
    ```
  </Collapser>
</CollapserGroup>

## Desbloquear serviços analíticos [#unblock-service]

O Sintético bloqueia a execução de scripts [de serviços analíticos populares](https://nr-synthetics-assets.s3.amazonaws.com/blacklists/blacklist.hosts) por padrão. Você pode permitir que o script seja executado para serviços específicos. Isso permite que o script do serviço seja executado e colete dados como faria para um usuário real.

```js
//Allow Google Analytics scripts to run
await $urlFilter.addToAllowList(['google-analytics.com']);

//Visit https://my-website.com
await $webDriver.get('https://my-website.com');
```

## Personalize o agente do usuário [#customize-user-agent]

Você pode personalizar o agente de usuário do browser com script para garantir que quaisquer correções específicas do browser em seu aplicativo estejam funcionando corretamente ou para ignorar um mecanismo de segurança para filtrar um site interno.

```js
//Simulate Internet Explorer 10.6
$headers.add('User-Agent', 'Mozilla/5.0 (compatible; MSIE 10.6; Windows NT 6.1; Trident/5.0; InfoPath.2; SLCC1; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET CLR 2.0.50727) 3gpp-gba UNTRUSTED/1.0');

//Visit http://httpbin.org/user-agent
await $webDriver.get('http://httpbin.org/user-agent');
```

<Callout variant="important">
  This only spoofs the user-agent HTTP header for the request to the server. It doesn't change the value of `navigator.userAgent`.
</Callout>

## Importar módulos opcionais [#importing]

You can also import many popular Node.js modules to enhance your test suite, automate the insertion of test data, and simplify complex functions. For more information, see [Importing Node.js modules](/docs/synthetics/synthetic-monitoring/scripting-monitors/import-nodejs-modules/).