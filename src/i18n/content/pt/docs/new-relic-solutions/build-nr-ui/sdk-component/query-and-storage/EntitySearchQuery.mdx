---
title: EntidadeSearchQuery
metaDescription: Learn how to work the EntitySearchQuery component
freshnessValidatedDate: '2024-06-03T00:00:00.000Z'
translationType: machine
---

Pesquise por entidade.

### Uso

```js
import { EntitySearchQuery } from 'nr1'
```

### Exemplos

#### Consulta declarativa

```js
function render() {
  const filters = [
    {
      type: EntitySearchQuery.FILTER_TYPE.TAG,
      value: { key: 'environment', value: 'production' },
    },
  ];


  return (
    <EntitySearchQuery filters={filters}>
      {({ loading, error, data, fetchMore }) => {
        if (loading) {
          return <Spinner />;
        }


        if (error) {
          return 'Error!';
        }


        return (
          <List
            items={data.entities}
            rowCount={data.count}
            rowHeight={20}
            onLoadMore={fetchMore}
          >
            {({ item }) => <ListItem key={item.guid}>{item.name}</ListItem>}
          </List>
        );
      }}
    </EntitySearchQuery>
  );
}
```

#### Buscar com critérios de classificação

```js
<EntitySearchQuery
  entityDomain="APM"
  sortBy={[EntitySearchQuery.SORT_TYPE.ALERT_SEVERITY]}
>
  {({ data, error, fetchMore }) => {
    if (error) {
      return 'Error!';
    }


    return (
      <List
        items={data.entities}
        rowCount={data.count}
        rowHeight={20}
        onLoadMore={fetchMore}
      >
        {({ item }) => <ListItem key={item.guid}>{item.name}</ListItem>}
      </List>
    );
  }}
</EntitySearchQuery>
```

#### Consulta imperativa

```js
EntitySearchQuery.query({
  filters: [
    {
      type: EntitySearchQuery.FILTER_TYPE.TAG,
      value: { key: 'environment', value: 'production' },
    },
  ],
}).then(({ data }) => console.log(data));
```

#### Obtenha mais resultados usando consulta imperativa

```js
const filters = [
  {
    type: EntitySearchQuery.FILTER_TYPE.TAG,
    value: { key: 'environment', value: 'production' },
  },
];


const firstPage = await EntitySearchQuery.query({ filters });


console.log('First page data', firstPage.data);


const cursor = firstPage.data.nextCursor;
const secondPage = await EntitySearchQuery.query({ cursor, filters });


console.log('Second page data', secondPage.data);


// NOTE: To fetch multiple page results consecutively, use EntitySearchQuery
// component's fetchMore approach.
```

### Props

<table>
  <tbody>
    <tr>
      <td>
        `children` <h5>função</h5>
      </td>

      <td>
        Renderize a função prop como uma criança.

        <FunctionDefinition
          returnValue={[{"type":"React.ReactNode","description":""}]}
          arguments={[{"name":"queryResult","type":"QueryResult","description":"Results of the query."}]}
        />
      </td>
    </tr>

    <tr>
      <td>
        `entityDomain` <h5>corda</h5>
      </td>

      <td>
        domínio da entidade que pretende consultar.
      </td>
    </tr>

    <tr>
      <td>
        `entityFragmentExtension` <h5>objeto</h5>
      </td>

      <td>
        Documento de fragmento GraphQL analisado em um AST por `graphql-tag`. Os componentes de consulta retornam os campos mais comumente usados disponíveis em uma entidade. Você pode usar esta prop quando quiser solicitar campos adicionais para a entidade retornada pela sua consulta. O fragmento deve ser nomeado `EntityFragmentExtension` e aplicar-se ao tipo `EntityOutline` .

        ```js
        const entityFragmentExtension = ngql`
          fragment EntityFragmentExtension on EntityOutline {
            indexedAt
            guid
          }
        `;
        ```
      </td>
    </tr>

    <tr>
      <td>
        `entityGuids` <h5>string\[]</h5>
      </td>

      <td>
        GUID da entidade a consultar.
      </td>
    </tr>

    <tr>
      <td>
        `entityType` <h5>corda</h5>
      </td>

      <td>
        Tipo de entidade que pretende consultar.
      </td>
    </tr>

    <tr>
      <td>
        `fetchPolicyType` <h5>enumeração</h5>
      </td>

      <td>
        Permite especificar como deseja que sua consulta interaja com os dados armazenados em cache.

        * `CACHE_AND_NETWORK`: a consulta retorna seus dados iniciais do cache, se disponíveis. Porém, independentemente de os dados completos estarem ou não em seu cache, a consulta sempre faz uma solicitação usando sua interface de rede e retorna os dados atualizados. Esta opção não está disponível ao usar o método estático `query()` do componente.

        * `CACHE_FIRST`: a consulta faz uma solicitação usando sua interface de rede **somente** se os dados da sua consulta ainda não estiverem no cache.

        * `CACHE_ONLY`: a consulta **nunca** faz uma solicitação usando sua interface de rede. Em vez disso, retorna os dados disponíveis no cache. Se os dados da sua consulta não existirem no cache, será gerado um erro.

        * `NETWORK_ONLY`: a consulta **nunca** retorna os dados iniciais do cache. Em vez disso, ele **sempre** faz uma solicitação usando sua interface de rede.

        * `NO_CACHE`: a consulta **nunca** retorna os dados iniciais do cache. Em vez disso, ele **sempre** faz uma solicitação usando sua interface de rede. Diferentemente da política `NETWORK_ONLY` , ela não grava nenhum dado no cache após a conclusão da consulta.

          <OptionReference>
            EntitySearchQuery.FETCH_POLICY_TYPE.CACHE_AND_NETWORK, EntitySearchQuery.FETCH_POLICY_TYPE.CACHE_FIRST, EntitySearchQuery.FETCH_POLICY_TYPE.CACHE_ONLY, EntitySearchQuery.FETCH_POLICY_TYPE.NETWORK_ONLY, EntitySearchQuery.FETCH_POLICY_TYPE.NO_CACHE,
          </OptionReference>
      </td>
    </tr>

    <tr>
      <td>
        `filters` <h5>string|(forma|forma|forma)\[]</h5>
      </td>

      <td>
        Filtros utilizados para restringir a entidade. Esta é uma matriz de filtros, e existem 3 filtros possíveis:

        * Filtro de consulta de pesquisa: `Object<type: string = "searchQuery", value: string>`
        * Filtro de tipo de entidade: `Object<type: string = "entityType", Object<domain: string, type: string>>`
        * Filtro de tags: `Object<type: string = "tag", Object<key: string, value: string>>`

        ```js
        const filters = [
          {
            type: 'searchQuery',
            value: 'foo',
          },
          {
            type: 'entityType',
            value: { domain: 'APM', type: 'APPLICATION' },
          },
          {
            type: 'tag',
            value: { key: 'environment', value: 'production' },
          },
          {
            type: 'tag',
            value: { key: 'team', value: 'bar' },
          },
        ];
        ```
      </td>
    </tr>

    <tr>
      <td>
        `includeCount` <h5>boleano</h5>
      </td>

      <td>
        Se `true`, a resposta da consulta inclui a contagem total de entidades para cada domínio e tipo.
      </td>
    </tr>

    <tr>
      <td>
        `includeResults` <h5>boleano</h5>
      </td>

      <td>
        Se `true`, a resposta da consulta inclui entidade.
      </td>
    </tr>

    <tr>
      <td>
        `includeSummaryMetrics` <h5>boleano</h5>
      </td>

      <td/>
    </tr>

    <tr>
      <td>
        `includeTags` <h5>boleano</h5>
      </td>

      <td>
        Se `true`, a entidade retornada inclui sua tag.
      </td>
    </tr>

    <tr>
      <td>
        `limit` <h5>número</h5>
      </td>

      <td>
        Paginação, número de entidade a buscar em cada página.
      </td>
    </tr>

    <tr>
      <td>
        `name` <h5>corda</h5>
      </td>

      <td>
        Nome ou nome parcial da entidade a consultar.
      </td>
    </tr>

    <tr>
      <td>
        `pollInterval` <h5>número</h5>
      </td>

      <td>
        Intervalo em milissegundos para pesquisar novos dados. Defina como zero para evitar qualquer tipo de pesquisa regular.
      </td>
    </tr>

    <tr>
      <td>
        `skip` <h5>boleano</h5>
      </td>

      <td>
        Quando definido como `true`, a consulta será totalmente ignorada da renderização.
      </td>
    </tr>

    <tr>
      <td>
        `sortBy` <h5>enum\[]</h5>
      </td>

      <td>
        matriz de critérios utilizados para ordenar os resultados da pesquisa da entidade.

        <OptionReference array>
          EntitySearchQuery.SORT_TYPE.alertas, EntitySearchQuery.SORT_TYPE.domínio, EntitySearchQuery.SORT_TYPE.MOST_RELEVANT, EntitySearchQuery.SORT_TYPE.NAME, EntitySearchQuery.SORT_TYPE.REPORTING, EntitySearchQuery.SORT_TYPE.TYPE,
        </OptionReference>
      </td>
    </tr>
  </tbody>
</table>

### Métodos

### `EntitySearchQuery.query`

<FunctionDefinition
  arguments={[{"description":"Object containing the query options. Any `EntitySearchQuery` prop is a valid option except `children` and `pollInterval`.","name":"props","type":"Object"}]}
  returnValue={{"description":"","type":"PromiseQueryResult"}}
/>

### Definições de tipo

<TypeDefReference typeDef={{"name":"PromiseQueryResult","properties":[{"description":"Runtime error with `graphQLErrors` and `networkError` properties.","name":"error","type":"ApolloClient.ApolloError"},{"description":"Object containing the result of your query.","name":"data","type":"Object"},{"description":"If not `null`, `fetchMore` allows you to load more results for your query. New data is merged with previous data.","name":"fetchMore","type":"function|null"},{"description":"Refetch the query.","name":"refetch","type":"function"}]}}/>

<TypeDefReference typeDef={{"name":"QueryResult","properties":[{"description":"Indicates that the request is in flight.","name":"loading","type":"boolean"},{"description":"Runtime error with `graphQLErrors` and `networkError` properties.","name":"error","type":"ApolloClient.ApolloError"},{"description":"Object containing the result of your query.","name":"data","type":"Object"},{"description":"If not `null`, `fetchMore` allows you to load more results for your query. New data is merged with previous data.","name":"fetchMore","type":"function|null"},{"description":"Refetch the query.","name":"refetch","type":"function"}]}}/>