---
title: OpenTelemetryの基礎
metaDescription: OpenTelemetry fundamentals
freshnessValidatedDate: never
translationType: machine
---

この章では、OpenTelemetry の基礎を学びます。 具体的には、OpenTelemetry 標準と実装のコア概念とコンポーネントについて説明します。 これにより、アプリケーションでそれをどのように、いつ、なぜ使用するかを学ぶことができます。

## 目的 [#objectives]

この章では、次のような質問に対する答えを学びます。

* OpenTelemetry とは何ですか?
* なぜそれに興味を持つべきなのでしょうか?
* どうやって使うんですか？

## 前提知識 [#prerequisite-knowledge]

この章を読む前に、次のようなテレメトリの概念を理解しておく必要があります。

* テレメトリーとは
* テレメトリーの仕組み
* テレメトリーがサポートするデータの種類
* トレースとは

以下の点についても理解しておく必要があります。

* キー値のペア、関数、クラスなどの一般的なプログラミングの概念
* ライブラリ、フレームワーク、リポジトリなどのプログラミング組織構造
* リクエスト、レスポンス、ステータスコードなどの一般的なネットワークの概念

<Steps>
  <Step>
    ## OpenTelemetry [#otel]

    [OpenTelemetry](https://opentelemetry.io) 、オープン インストゥルメンテーションのエキサイティングな新しい標準であり、エンドユーザー、クラウド プロバイダー、および可用性リーダー ( New Relicを含む) で構成される大規模な開発者コミュニティによってサポートされています。 前身の[OpenTracing](https://opentracing.io)と同様に、これは CNCF プロジェクトであり、現在は成熟の[インキュベーション](https://landscape.cncf.io/card-mode?project=incubating)段階にあります。

    OpenTelemetry AI モニタリング:

    * アプリケーションがテレメトリデータを収集し、バックエンドプラットフォームに送信する方法を標準化します。 この標準により、クライアントとオブザーバビリティ プラットフォームはデータの外観について合意するため、データを利用するために特定のプラットフォームのエコシステムに縛られる必要がなくなります。

    * テレメトリデータのエンドツーエンドの可視性を向上させます。 OpenTelemetry 、ライブラリとフレームワークがプラットフォームに依存せず実装に依存しない方法でテレメトリデータを生成する方法を定義します。 これは、より多くのツールがOpenTelemetryを採用できることを意味し、特に異なるテクノロジーを使用する分散システムでは、耐障害性が向上します。

      OpenTelemetry 、テレメトリーデータの外観や使用方法などの仕様と、最も人気のあるプログラミング言語の多くでその仕様をすぐに使用できる実装の両方を提供することで、これらの目標を達成します。

    * 仕様。 OpenTelemetry は、何よりもまず仕様です。 テレメトリーデータの標準的な定義と、 OpenTelemetryインストゥルメンテーションの構築方法および使用方法を説明します。

    * 実装。 OpenTelemetryのAPIおよび SDK 仕様は、テレメトリーデータを操作するためのクラス、関数、および設定メカニズムを定義します。 しかし、OpenTelemetry は、最も人気のあるプログラミング言語の多くで標準に準拠した実装も提供しています。

      <Callout variant="tip">
        プラットフォーム固有のソリューションは、多くの場合、 OpenTelemetryよりも多くのバックエンドプラットフォームの機能をサポートしており、 New Relicも例外ではありません。 これは現時点では事実ですが、OpenTelemetry が成熟するにつれて、この差は縮小するでしょう。

        当社のプラットフォームが独自のエージェントをどのようにサポートしているかと、OpenTelemetry をどのようにサポートしているかを比較するには、 [ドキュメント](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-introduction//#choice)をお読みください。
      </Callout>
  </Step>

  <Step>
    ## OpenTelemetry仕様 [#otel-specification]

    この仕様では、テレメトリーデータの標準的な定義と、 OpenTelemetryインストゥルメンテーションの構築方法が説明されています。

    具体的には、次の内容について説明します。

    * サポートされる各テレメトリデータ タイプの**データ モデル**。 この仕様には、ネットワーク経由でデータを送信するためのプロトコルと、一般的な操作やテクノロジのデータを記述するための従来の属性が含まれています。

    * テレメトリデータが一貫した方法で生成されるようにするクラスと関数で構成されるアプリケーション プログラミング インターフェイス ( **API** )。

    * によって生成されたテレメトリデータを構成、処理、およびエクスポートするためのメカニズムを備えたソフトウェア開発キット (** SDK**)API。

      標準化されたデータ モデルは、開発者とオブザーバビリティ プラットフォームがデータ構造の外観、コード内での表現方法、サービス間でのシリアル化および転送方法について合意できるため便利です。 エンドユーザーは、競合するプラットフォームと、データが一貫して生成されフォーマットされるという確信を持って仕様に準拠したツールのどちらかを選択できます。

      インストゥルメンテーションを構築する標準的な方法により、サポートされているすべてのプログラミング言語間で一貫性が確保されます。 OpenTelemetry仕様に準拠したツールを使用してアプリケーションを設計すると、それらがどのように機能し、一貫した方法でテレメトリデータを生成するかがわかります。

      <Callout variant="tip">
        OpenTelemetry 仕様のさまざまなコンポーネントを区分すると役立ちます。 開発者は、データ仕様に準拠しているが、 APIまたは SDK 仕様に準拠していないインストゥルメンテーション ライブラリを作成できます。 言い換えれば、それらのライブラリは、 OpenTelemetry仕様に一致するデータを生成して送信しながらも、異なるインターフェースと設定メカニズムを持つ可能性があります。

        仕様とそのコンポーネントの詳細については、後のレッスンで学習します。
      </Callout>
  </Step>

  <Step>
    ## OpenTelemetryデータモデル仕様 [#otel-data-model]

    データ モデルは、テレメトリーデータ構造がどのようになるかを指定します。 OpenTelemetry では、これらのデータ構造は**シグナル**と呼ばれます。 サポートされるシグナルは、このコースの前半で学習したテレメトリーデータ タイプ (trace、メトリクス、およびログ) とほぼ一致します。

    各信号には、次の内容を含む独自のデータ モデル仕様があります。

    * **Semantic conventions**\[セマンティック規則]: 一般的な操作、テクノロジ、イベント、プロトコルを記述する規則的な属性。

    * **OpenTelemetry プロトコル (OTLP) 仕様**: 各データ信号を OpenTelemetry の交換プロトコルでエンコードして転送する方法の説明。

      データ モデルが提供するものをより具体的に知るには、トレース データ モデルを参照してください。
  </Step>

  <Step>
    ## トレースデータモデルのセマンティック規則 [#trace-data-model]

    OpenTelemetry トレース信号は、リンクされたスパンの階層的なコレクションで構成されます。 各スパンは、スパンの名前、開始時刻、終了時刻などのメタデータ フィールドと、属性のリストおよびイベントのリストで構成されます。 スパンの定義とそれに含まれるフィールドは、トレース用のOpenTelemetryデータ仕様に準拠するすべてのテレメトリ ツールに共通です。

    名前フィールドは、スパンが表す操作を識別します。 たとえば、名前は Web サービスのエンドポイントまたは関数である可能性があります。

    開始時刻フィールドと終了時刻フィールドは、それぞれ操作が開始された時刻と終了した時刻を表します。 これらの時間は、すべてのサブ操作を含む操作の合計経過時間を表します。

    他にも重要な[スパン フィールド](https://opentelemetry.io/docs/reference/specification/trace/api/#span)がありますが、そのうちのいくつかは OpenTelemetry でのトレースの実装に特に関連しているため、後のレッスンで詳しく学習します。 span モデルを含むすべての OpenTelemetry データ モデルのシンプルですが、非常に重要なコンポーネントの 1 つが**属性**です。

    ### 属性 [#attributes]

    属性は、強調表示する機能を表すキー値のペアです。 たとえば、スパンが、ユーザーが製品をカートに追加するためのオンライン ストアへの Web リクエストを表す場合、製品の ID をスパンの属性として保存することができます。 こちらはカスタムアトリビュートの一例です。

    一般的な操作、テクノロジー、概念、プロトコルを記述するための従来の属性もあります。 たとえば、データベースクエリを表すスパンには、データベースのユーザーを表す`db.user`という名前の属性が必要です。 リクエストを処理する Web サービスを表すスパンには、ノードのポート番号を格納する`net.peer.port`という名前の属性が必要です。 セマンティック規則と呼ばれるこれらの規則は、これらの共通機能のキーと値を標準化します。

    HTTP、gRPC、メッセージング プロトコルなどの一般的なテクノロジーをサポートするライブラリは、操作を記述するときにこれらのセマンティック規則を使用する必要があります。 これらのキーはすべて必須ではありませんが、ライブラリが属性内のデータをキャプチャする場合は、規則に従う必要があります。

    <Callout variant="tip">
      これらの規則は、ツール開発者がこれらの特性を何と呼ぶかについて統一するだけでなく、安全性プラットフォームの背後にも役立ちます。 従来の属性は、サバビリティプラットフォームではOpenTelemetry実装からの一貫性を期待できることを意味します。 その一貫性に依存して、特定のユーザーエクスペリエンスとそれらの属性を活用するツールを構築できます。

      たとえば、New Relic は、データベース操作を表すスパンにこれらの広く採用されている属性が含まれていることを認識しているため、プログラムでデータ内の属性を見つけ、それらを使用して特定のエクスペリエンスを作成できます。
    </Callout>

    属性と同様に、スパン イベントはトレース データ モデルのもう 1 つの重要なコンポーネントです。

    ### スパンイベント [#span-events]

    スパン イベントは、スパンの操作中に発生するイベントを表します。 たとえば、関数が例外を発生させた場合、その例外に関する詳細を span イベントでキャプチャできます。

    関連する span と同様に、span イベントには、メタデータ (具体的には名前とタイムスタンプ) のほか、イベントの機能を強調するいくつかの属性があります。

    例外イベントの場合、その属性の一部はセマンティック規則に対応します。 たとえば、例外イベントは、スタックトレースを`exception.stacktrace`という属性に格納します (存在する場合)。 `exception.message`という属性がある場合は、そこにメッセージを保存します。 スパン イベントは、スパンの操作中に何が起こるかを理解するのに非常に役立ちます。

    <Callout variant="tip">
      New Relic などの一部のサービスでは、イベントをファーストクラスのデータ構造として扱う場合があります。 OpenTelemetry では、イベントはスパンに直接関連しています。
    </Callout>

    OpenTelemetry データ モデル仕様では、信号のメタデータとセマンティック規則が定義されていることを学習しました。 スパンの場合には、スパンの名前、タイムスタンプ、属性、セマンティック規則、イベントなどが含まれます。 ただし、仕様では、信号をテレメトリー クライアントから送信できるようにシリアル化する方法も定義されています。
  </Step>

  <Step>
    ## OpenTelemetry プロトコル (OTLP) [#otel-protocol]

    OpenTelemetry 仕様には、ネットワーク サービス間でデータをシリアル化、逆シリアル化、転送する方法を定義する交換プロトコル OTLP が含まれています。 このプロトコルの目的は、データ モデルに厳密に準拠し、 [他のテレメトリ プロトコルに存在する問題を](https://opentelemetry.io/docs/reference/specification/protocol/requirements/#known-issues-with-existing-protocols)解決するシリアル化スキーマを指定することです。 また、データをシリアル化して送信できるクライアントを一般的に実装する方法と、シリアル化されたデータを受け入れてその応答で成功または失敗を示すことができるサーバーを実装する方法も定義します。

    OTLP は、プロトコル バッファを使用してテレメトリ データをシリアル化し、gRPC または HTTP を使用して送信します。 このプロトコルは、テレメトリ クライアントからデータを受信するオブザバビリティ プラットフォームまでのすべてのノード、およびその間のサービス、エージェント、コレクター、フォワーダーで機能します。

    OTLP はOpenTelemetryデータ仕様に関連しています。仕様では、各信号のデータが高レベルでどのように見えるかを定義するだけでなく、コード レベルでどのように見えるかも指定しているからです。 具体的には、データをシリアル化してネットワーク経由で送信するために使用するプロトコル バッファー スキーマを定義します。

    以下は[thetrace プロトコル バッファ スキーマ](https://github.com/open-telemetry/opentelemetry-proto/blob/main/opentelemetry/proto/trace/v1/trace.proto)からのスニペットです。

    ```
    message Span {
    bytes trace_id = 1;
    bytes span_id = 2;
    string trace_state = 3;
    bytes parent_span_id = 4;
    string name = 5;
    SpanKind kind = 6;
    fixed64 start_time_unix_nano = 7;
    fixed64 end_time_unix_nano = 8;
    repeated opentelemetry.proto.common.v1.KeyValue attributes = 9;
    uint32 dropped_attributes_count = 10;
    repeated Event events = 11;
    uint32 dropped_events_count = 12;
    repeated Link links = 13;
    uint32 dropped_links_count = 14;
    Status status = 15;
    }
    ```

    このメッセージはトレースの範囲を表します。 トレースの実装方法をまだ学習していないため、最初のいくつかのフィールドはわからないかもしれませんが、他のほとんどのフィールドは見覚えがあるはずです。

    * メッセージの**5 番目の**フィールドはスパンの名前です。 前に学んだように、スパンの名前は、スパンが表す操作を識別する文字列です。
    * **7 番目**と**8 番目の**フィールドは、それぞれスパンの開始タイムスタンプと終了タイムスタンプです。 これらは、UNIX エポック (1970 年 1 月 1 日) からのナノ秒数を表す 8 バイトの整数として保存されます。 フォーマットされたタイムスタンプ文字列を送信するよりも、ネットワーク経由で整数を送信する方が効率的です。
    * **9 番目の**フィールドは、スパンの属性を`KeyValue`要素のコレクション（「繰り返し」データ型で示される）として表します。
    * **11 番目の**フィールドには、 `Event`オブジェクトのコレクションが格納されます。

    スキーマでは、 `Event`や、プリミティブ型よりも複雑なその他のカスタム データ型には独自の定義があります。 この場合、次のようになります。

    ```
    message Event {
    fixed64 time_unix_nano = 1;
    string name = 2;
    repeated opentelemetry.proto.common.v1.KeyValue attributes = 3;
    uint32 dropped_attributes_count = 4;
    }
    ```

    これは、前のレッスンで学習したデータ モデルとほぼ 1 対 1 で一致するため、ほとんど馴染みのあるものであるはずです。

    データ仕様を参照したり操作したりする場合は、OpenTelemetry がまだ進化中の製品であることを念頭に置くことが重要です。 一部のデータ信号は安定しており、長期サポートが提供され、下位互換性のない変更を伴う後続のマイナー リリースが行われないことが保証されています。 ただし、その他のものは実験段階であったり、現在テスト中であったりするため、安定性が保証されません。 各スキーマの成熟度を確認するには、[OpenTelemetry-proto リポジトリ](https://github.com/open-telemetry/opentelemetry-proto#maturity-level) の** 成熟度レベル **\[Maturity Level]チャートを参照してください。

    素晴らしい! OpenTelemetry データ仕様について、以下を含めてすべて学習しました。

    * シグナルとは
    * 各信号について仕様が定義するもの
    * トレースデータモデルの概要
    * OpenTelemetryのスコープに含まれる属性
    * スパンのイベントとは
    * 仕様がデータモデルに従ってOTLPスキーマを定義する方法

    ただし、仕様はテレメトリーデータの定義だけでは終わりません。 また、そのデータと対話するためのインターフェースも指定します。
  </Step>

  <Step>
    ## OpenTelemetry API仕様 [#otel-api-spec]

    これまで、 OpenTelemetry仕様が各テレメトリーデータ信号のデータ モデル、セマンティック規則、および OTLP スキーマをどのように定義するかを学習しました。 しかし、仕様ではテレメトリーデータの外観以上のものが定義されています。 また、そのデータの処理方法も定義します。

    OpenTelemetry API 仕様では、データ信号と対話するために使用するクラスと関数について説明します。 たとえば、 OpenTelemetry実装でスパンを生成したり、メトリックの測定値を報告したりする方法について説明します。

    OpenTelemetryインストゥルメンテーション 開発者にとって、この仕様は他のAPI OpenTelemetry準拠ツールと一貫性のある を構築するための青写真となります。API を使用するフレームワーク、ライブラリ、アプリ開発者にとって、この仕様は一貫性を保証し、準拠しているすべてのツールとどのように対話できるかについてのドキュメントを提供します。

    API 仕様には 2 つの重要なコンポーネントがあります。

    * テレメトリーデータを操作するのに使用する**インターフェースの定義**
    * そのインターフェースの**最小限の実装**
  </Step>

  <Step>
    ## インターフェースの定義 [#defining-interface]

    API 仕様が最初に提供するものは、シグナルと対話するためのクラスと関数の定義です。

    たとえば、仕様ではトレースを操作するための 3 つの主要なクラスが定義されています。

    * `TracerProvider` は、ご想像のとおり、トレーサーを提供するクラスです。 一部のアプリでは複数のトレーサープロバイダーを使用することがありますが、通常は単一のグローバル トレーサープロバイダーを使用します。 トレーサー プロバイダーは、スパンの処理方法やスパンのサンプリング方法などの特定の設定を保持します。

    * `Tracer` プロセスに関する情報を収集するスパンを作成するために使用するクラスです。 覚えておいてください。トレーサーがスパンを作成する方法と、記録されたときにスパンをどのように処理するかを指示する設定は、トレーサーではなくトレーサー プロバイダーが保持します。

    * `Span` 操作に関するデータを取得します。 複数のスパンがトレースを構成します。 データ モデルの仕様について学習したときに、OpenTelemetry スパンの外観について多くのことを学びました。 ただし、スパンには保持されるデータ以外にも多くのものがあります。

      たとえば、スパンにはその期間を決定する start メソッドと end メソッドがあります。 スパンの値を更新できるかどうかを確認するために使用する`IsRecording()`というメソッドがあります。 また、属性やイベントを追加するなど、それらの値を更新するためのメソッドも備えています。 シグナルと対話するためのこれらのインターフェースはすべて、API 仕様によって定義されています。

      <Callout variant="tip">
        仕様ではシグナルと対話するために使用するクラスと関数が定義されていますが、メソッド名の大文字と小文字の区別などの言語レベルの詳細は実装によって異なる場合があります。
      </Callout>

      API 仕様で定義されるもう 1 つの側面は、「最小限の実装」と呼ばれるものです。
  </Step>

  <Step>
    ## 最小限の実装 \[minimal-implementation]

    API はデータを操作するためのインターフェースを定義しますが、実質的に何もしない実装も必要です。 この「最小限の」実装ではオーバーヘッドが非常に少なく、副作用もありません。

    API 、インストゥルメンテーション ライブラリなどのテレメトリーデータを扱うプログラムによって使用されます。ネットワーク リクエストやデータベースなどの特定のテクノロジと対話するためのフレームワーク。およびそれらのツールを使用するアプリケーション。 ただし、OpenTelemetry API によって生成されたデータをどのように使用するかを知っているのは、アプリケーション開発者だけです。 API最小限の実装により、開発者はアプリケーションが を使用するかどうかに関係なく、コードに インタラクションを組み込むことができます。OpenTelemetry

    たとえば、データベース ライブラリ開発者が、コードを作成して、ユーザーがコードによって生成されたテレメトリデータを使用できるようにしたいとします。 開発者はトレーサー プロバイダーを構成し、それを使用してトレーサーを作成し、そのトレーサーを使用してコード全体にスパンを作成します。 ユーザーは、テレメトリーデータを必要としているかどうかを知ったり気にしたりすることなく、これらすべて、そしてそれ以上のことを実行できます。しかも、インストゥルメンテーションは効果的で副作用がないという安心感があります。

    ユーザーが OpenTelemetry を使用する場合は、実装を構成します。 API を使用するライブラリは、ユーザーの希望どおりに適切なデータを自動的に生成して送信し始めます。 ユーザーがOpenTelemetryを使用したくない場合、 API最小限の実装を使用しますが、実際にはテレメトリデータは生成されません。

    これにより、OpenTelemetry API を使用する開発者に一貫性が提供されます。 また、ライブラリの特別な、インストゥルメントされたバージョンを必要としないことで、開発者の負担も軽減されます。 これらの障壁を取り除くことで、 OpenTelemetryより簡単に導入でき、導入が進むほどギャップが減り、すべての人にとってテレメトリデータが向上します。

    データ モデル仕様と同様に、各シグナルの API 仕様は成熟度が異なる段階にあることを覚えておくことが重要です。 API 仕様の成熟度に関する最新情報については[、OpenTelemetry ステータス ページを](https://opentelemetry.io/status/)ご覧ください。

    API 仕様で定義されている内容の例をいくつか見てきましたが、ここで少し立ち止まって、定義されていない内容を明確にすることが重要です。
  </Step>

  <Step>
    ## 関心事の分離 \[separating-concerns]

    API は、OpenTelemetry 信号と対話するために使用するインターフェースを定義します。 これを使用して、テレメトリーデータを生成するコードを設定します。 API 自体は実際にデータを生成しません。それは実装の責任です。

    OpenTelemetry は、シグナルのインターフェースと、インターフェースと対話するときに実行されるロジックである実装を分離します。 これにより、API のユーザーは、API がどのように実装されているかを正確に知ったり気にしたりする必要がなくなります。 また、実装を構成可能にすることもできます。

    API のユーザーはインターフェースの背後にあるロジックを理解できないため、そのロジックは、ユーザーがデータをどのように使用したいかに応じて、さまざまな形式をとることができます。 API の実装を構成することが SDK の目的です。
  </Step>

  <Step>
    ## OpenTelemetry SDK について [#otel-sdk]

    OpenTelemetry は、サポートする各信号の仕様を提供します。 これらにはデータ モデルと API の説明が含まれていることは既に確認しましたが、SDK の説明も含まれています。 SDK 仕様では、API の背後にあるロジックを実装するための要件が定義されています。 SDK 仕様の詳細を学ぶ前に、SDK の使用方法を示す図が役に立つかもしれません。

    OpenTelemetryでインストゥルメントされたライブラリでサポートされているアプリケーションを構築していると想像してください。 これまで、テレメトリーデータをどのように使用するか定義していなかったため、それらのライブラリが対話するAPI最小限の実装を使用しています。 言い換えれば、ライブラリはデータを生成したり送信したりはしませんが、そのための機能が備わっています。 これで、そのインストゥルメンテーションを利用するために SDK を構成する準備が整いました。

    まず、テレメトリーデータをどのように使用するかを決定します。 トレースについては、スパンをどのように処理するか、どのようにサンプリングするか、収集したらどのようにどこに送信するかを決定します。 API でデータをどのように処理するかが決まったら、SDK のインターフェースを使用して実装を構成します。

    仕様では、SDK を構成するための 3 つのメカニズムが定義されています。

    * 互換性のある実装を提供する**プラグイン**

    * 環境変数やオブジェクトなどの**コンストラクタ**。設定を保持したり、プラグインを受け入れたり、リソースを作成したりする。

    * テレメトリーデータを生成する環境を識別する**リソース**

      プラグインを適用してコンストラクターを構成すると、 APIインターフェースは希望どおりの結果を生成します。 最小限の実装は使用されなくなり、代わりに構成した実装が使用されます。 APIどの実装が使用されているかを認識しておらず、気にも留めないため、インストゥルメンテーションではコードの変更は必要ありません。

      SDK がどのように動作するかの概要例を確認したので、次は仕様でプラグインとコンストラクター インターフェイスがどのように定義されているかを学習します。
  </Step>

  <Step>
    ## SDK プラグイン [#sdk-plugins]

    API がデータをどのように処理するかを定義する方法の 1 つは、プラグインを使用することです。 たとえば、特定の方法でデータをサンプリングする場合は、ニーズに合わせてサンプラー プラグインを使用できます。 別のサンプラーに変更したい場合は、プラグインを交換することができます。

    SDK 仕様では、SDK が受け入れるプラグインの種類と、それらのプラグインが実装する必要があるインターフェースの両方が定義されています。 このインターフェース定義により、開発者は新しいプラグインを簡単に作成できます。 また、カスタム動作が必要な場合は、仕様を使用して独自の動作を記述することもできます。

    トレース SDK は、次のようないくつかのタイプのプラグインを受け入れます。

    * **Span exporter**\[スパンエクスポーター]:データをエンコードして消費者に送信する

    * **Span processor**\[スパンプロセッサ]:スパンデータを強化およびフィルタリングし、エクスポーターが処理できる形式に変換します。

    * **Sampler**\[サンプラー]:ユーザーがスパンサンプリングを制御できるようにします

      これらのプラグイン タイプごとに、SDK 仕様でインターフェースまたは必要なメソッドが定義されます。

      たとえば、span エクスポーター プラグインは次の 2 つの関数を実装する必要があります。

    * **Export**\[エクスポート]:スパンを受信し、シリアル化して、指定された消費者に送信します。

    * **Shutdown**\[シャットダウン]:エクスポート環境をクリーンアップします

      仕様で要求されているため、API インタラクションでは、使用されているプラグインに関係なく、適切なタイミングでこれらの関数を呼び出すことができます。

      仕様では、SDK の実装に含める必要があるプラグインも定義されています。 たとえば、SDK は単純なスパン プロセッサとバッチ プロセッサを提供する必要があることを宣言します。 シンプル スパン プロセッサは、スパンが終了するとすぐにそれを処理します。 バッチ プロセッサは、完了したスパンをバッチ処理してからエクスポーターに渡します。

      SDK プラグインは、特定の方法で API インターフェースを実装するモジュール式の論理コンポーネントです。 テレメトリーデータの目的に最適なプラグインを選択します。 プラグインを選択したら、SDK コンストラクターを使用してプラグインをさらに構成し、API に割り当てることができます。
  </Step>

  <Step>
    ## SDK コンストラクター [#sdk-constructors]

    仕様では、OpenTelemetry 実装を構成する方法としてコンストラクターを定義します。 コンストラクターには、環境変数と設定クラスが含まれます。

    たとえば、SDK には、前のレッスンで学習した OpenTelemetry の交換プロトコルである OTLP を介してデータを送信するための組み込みエクスポータ プラグインが用意されています。 OTLP エクスポータ仕様では、エクスポータがトレース データを送信する URL を指定する`OTEL_EXPORTER_OTLP_TRACES_ENDPOINT`など、構成に使用するいくつかの環境変数が定義されています。

    仕様では、API 実装を構成するために使用するクラスも定義されています。 トレースの場合、これはすでに学習したトレーサー プロバイダーです。 トレーサー プロバイダーを使用して、スパンを作成するトレーサーを作成します。 トレーサー プロバイダーは、スパンの生成、処理、およびエクスポート方法に関する設定を保持します。 API を実装するためのプラグインを提供する方法です。

    OpenTelemetry SDK 仕様では、プラグインやコンストラクターとともに、テレメトリデータを生成する環境を識別する方法が定義されています。 この SDK コンポーネントは**リソース**と呼ばれます。
  </Step>

  <Step>
    ## 資力 [#resources]

    リソースは、属性によってプロジェクトの環境を識別するために使用します。 たとえば、ホストを説明するには、ホスト名と仮想マシン イメージの属性を含めることができます。 サービスを説明するために、サービス ネームスペースとバージョンを含めることができます。 テレメトリー インストゥルメンテーションを説明するために、SDK 名とバージョンを含めることができます。

    OpenTelemetry 仕様では、信号の場合と同様に、リソースのセマンティック規則が提供されます。 リソースに必要な唯一の慣例属性は`service.name`です。 オプションの慣例属性については、 [仕様](https://opentelemetry.io/docs/reference/specification/resource/semantic_conventions/#semantic-attributes-with-sdk-provided-default-value)を参照してください。

    環境用のリソースを作成したら、それをコンストラクターに含めることができます。 トレースの場合、これはリソースをトレーサー プロバイダーに接続することを意味します。 スパンは作成すると、環境のリソースに関連付けられます。

    データ モデルや API 仕様と同様に、一部の SDK 仕様は他の仕様よりも成熟しています。 たとえば、リソース仕様は安定していますが、リソースのセマンティック規則はまだ実験段階です。 SDK 仕様の成熟度に関する最新情報については[、OpenTelemetry ステータス ページを](https://opentelemetry.io/status/)ご覧ください。

    仕様としての OpenTelemetry について多くのことを学びました。 これは OpenTelemetry を理解するための基礎となります。なぜなら、これを中心に構築されるものはすべて仕様に準拠しているからです。 しかし、OpenTelemetry には、多くの一般的なプログラミング言語で仕様を実装する公式コード リポジトリも含まれています。
  </Step>

  <Step>
    ## OpenTelemetryの実装 [#otel-implementations]

    OpenTelemetry は単なる仕様ではありません。 また、最も人気のあるプログラミング言語の多くで公式実装も提供しています。

    * [.NET](https://github.com/open-telemetry/opentelemetry-dotnet)
    * [C ++](https://github.com/open-telemetry/opentelemetry-cpp)
    * [アーラン/エリクサー](https://github.com/open-telemetry/opentelemetry-erlang)
    * [Go](https://github.com/open-telemetry/opentelemetry-go)
    * [Java](https://github.com/open-telemetry/opentelemetry-java)
    * [JavaScript](https://github.com/open-telemetry/opentelemetry-js)
    * [PHP](https://github.com/open-telemetry/opentelemetry-php)
    * [Python](https://github.com/open-telemetry/opentelemetry-python)
    * [Ruby](https://github.com/open-telemetry/opentelemetry-ruby)
    * [さび](https://github.com/open-telemetry/opentelemetry-rust)
    * [迅速](https://github.com/open-telemetry/opentelemetry-swift)

    仕様と同様に、これらの実装も進化しています。 [コンプライアンス マトリックス](https://github.com/open-telemetry/opentelemetry-specification/blob/main/spec-compliance-matrix.md)を確認して、希望する言語がどの程度進んでいるかについて詳しく確認してください。

    OpenTelemetry 、 APIを使用してデータを生成する、手動および自動形式のインストゥルメンテーションを提供します。

    ### 手動計測器 [#manual-instrumentation]

    手動インストゥルメンテーションでは、開発者が SDK を使用してAPIを構成し、 APIを使用してデータを作成およびエクスポートする必要があります。 トレースの観点で言えば、これは、 トレーサー プロバイダーを作成し、 トレーサー を作成し、データを収集する操作ごとにスパンを作成することを意味します。 ライブラリまたはフレームワークをネイティブに実装しようとしている場合は、手動インストゥルメントを使用します。

    ### 自動インストゥルメンテーション [#automatic-instrumentation]

    自動インストゥルメンテーションでは、自分でコードを記述しなくても、手動インストゥルメンテーションと同じテレメトリーデータが提供されます。 自動インストゥルメンテーションは一般的なライブラリとフレームワークに限定されているため、それらのプロジェクトのいずれかを使用しているアプリケーション開発者のみが使用できます。 幸いなことに、多くの一般的なオープンソース ライブラリとフレームワーク用の自動インストゥルメンテーションを見つけることができます。

    <Callout variant="tip">
      OpenTelemetry開発者は、プログラム的に操作し、インストゥルメントされたコードによって自動インストゥルメンテーションを提供できます。 たとえば、 OpenTelemetry Java エージェントは、アプリケーションのバイトコードを書き換えてインストゥルメンテーションを追加します。 ただし、ライブラリ インストゥルメンテーションも提供できます。 これにはいくつかの形式があります:

      * OpenTelemetryはライブラリに直接組み込むことができます
      * インストゥルメンテーションコードは、ライブラリにある特別な目的の拡張フックを利用できます。
      * ライブラリのラップバージョンにはインストゥルメンテーションレイヤーを含めることができます
    </Callout>

    ### リポジトリ構造 [#repository-structure]

    OpenTelemetry の実装には、SDK インターフェース、API インターフェース、プラグイン、セマンティック規則など、多くのコンポーネントが含まれており、その実装はすべて同じではありません。 これらは、実装されている言語に慣用的な決定を下すだけでなく、概念を異なる方法で分離します。

    たとえば、1 つの言語には、すべての OpenTelemetry コード用の 1 つのリポジトリが存在する場合があります。 別の言語では、手動のインストゥルメンテーションと自動のインストゥルメンテーションを独自のリポジトリに分けることがあります。 優先する言語の詳細については、 [OpenTelemetry のドキュメント](https://opentelemetry.io/docs/instrumentation/)を参照してください。
  </Step>
</Steps>