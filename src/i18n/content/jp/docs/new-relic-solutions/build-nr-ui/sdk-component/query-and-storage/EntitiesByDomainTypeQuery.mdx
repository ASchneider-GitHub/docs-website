---
title: エンティティByDomainTypeクエリ
metaDescription: Learn how to work the EntitiesByDomainTypeQuery component
freshnessValidatedDate: '2024-06-03T00:00:00.000Z'
translationType: machine
---

entityDomain と entityType でエンティティをクエリします。

### 使用方法

```js
import { EntitiesByDomainTypeQuery } from 'nr1'
```

### 例

#### 宣言型クエリ

```js
<EntitiesByDomainTypeQuery entityDomain="APM" entityType="APPLICATION">
  {({ error, data, fetchMore }) => {
    if (error) {
      return 'Error!';
    }


    return (
      <List
        items={data.entities}
        rowCount={data.count}
        rowHeight={20}
        onLoadMore={fetchMore}
      >
        {({ item }) => <ListItem key={item.guid}>{item.name}</ListItem>}
      </List>
    );
  }}
</EntitiesByDomainTypeQuery>
```

#### 並べ替え基準を指定して取得

```js
<EntitiesByDomainTypeQuery
  entityDomain="INFRA"
  entityType="HOST"
  sortBy={[EntitiesByDomainTypeQuery.SORT_TYPE.ALERT_SEVERITY]}
>
  {({ data, error, fetchMore }) => {
    if (error) {
      return 'Error!';
    }


    return (
      <List
        items={data.entities}
        rowCount={data.count}
        rowHeight={20}
        onLoadMore={fetchMore}
      >
        {({ item }) => <ListItem key={item.guid}>{item.name}</ListItem>}
      </List>
    );
  }}
</EntitiesByDomainTypeQuery>
```

#### 命令型クエリ

```js
EntitiesByDomainTypeQuery.query({
  entityDomain: 'APM',
  entityType: 'APPLICATION',
}).then(({ data }) => console.log(data));
```

#### 命令型クエリを使用してより多くの結果を取得する

```js
const firstPage = await EntitiesByDomainTypeQuery.query({
  entityDomain: 'APM',
  entityType: 'APPLICATION',
});


console.log('First page data', firstPage.data);


const cursor = firstPage.data.nextCursor;
const secondPage = await EntitiesByDomainTypeQuery.query({
  cursor,
  entityDomain: 'APM',
  entityType: 'APPLICATION',
});


console.log('Second page data', secondPage.data);


// NOTE: To fetch multiple page results consecutively,
// use EntitiesByDomainTypeQuery component's fetchMore approach.
```

### 小道具

<table>
  <tbody>
    <tr>
      <td>
        `children` <h5>機能</h5>
      </td>

      <td>
        prop関数を子としてレンダリングします。

        <FunctionDefinition
          returnValue={[{"type":"React.ReactNode","description":""}]}
          arguments={[{"name":"queryResult","type":"QueryResult","description":"Results of the query."}]}
        />
      </td>
    </tr>

    <tr>
      <td>
        `entityDomain` <h5>必須</h5><h5>文字列</h5>
      </td>

      <td>
        クエリを実行するエンティティのドメイン。
      </td>
    </tr>

    <tr>
      <td>
        `entityFragmentExtension` <h5>物体</h5>
      </td>

      <td>
        GraphQL フラグメント ドキュメントは`graphql-tag`によって AST に解析されます。クエリ コンポーネントは、エンティティで使用可能な最も一般的に使用されるフィールドを返します。 クエリによって返されるエンティティの追加フィールドを要求する場合に、このプロパティを使用できます。フラグメントの名前は`EntityFragmentExtension`とし、 `EntityOutline`タイプに適用する必要があります。

        ```js
        const entityFragmentExtension = ngql`
          fragment EntityFragmentExtension on EntityOutline {
            indexedAt
            guid
          }
        `;
        ```
      </td>
    </tr>

    <tr>
      <td>
        `entityType` <h5>必須</h5><h5>文字列</h5>
      </td>

      <td>
        クエリするエンティティのタイプ。
      </td>
    </tr>

    <tr>
      <td>
        `fetchPolicyType` <h5>enum</h5>
      </td>

      <td>
        クエリがキャッシュされたデータとどのようにやり取りするかを指定できます。

        * `CACHE_AND_NETWORK`: クエリは、利用可能な場合はキャッシュから初期データを返します。 ただし、完全なデータがキャッシュ内にあるかどうかに関係なく、クエリは常にネットワーク インターフェイスを使用して要求を行い、更新されたデータを返します。 このオプションは、コンポーネントの静的`query()`メソッドを使用する場合は使用できません。

        * `CACHE_FIRST`: クエリのデータがまだキャッシュ内に存在しない場合に**のみ**、クエリはネットワーク インターフェイスを使用して要求を行います。

        * `CACHE_ONLY`: クエリはネットワーク インターフェイスを使用して要求を行うことは**ありません**。 代わりに、キャッシュ内で利用可能なデータを返します。 クエリのデータがキャッシュ内に存在しない場合は、エラーがスローされます。

        * `NETWORK_ONLY`: クエリはキャッシュから初期データを返すこと**はありません**。 代わりに、**常に**ネットワーク インターフェイスを使用して要求が行われます。

        * `NO_CACHE`: クエリはキャッシュから初期データを返すこと**はありません**。 代わりに、**常に**ネットワーク インターフェイスを使用して要求が行われます。 `NETWORK_ONLY`ポリシーとは異なり、クエリの完了後にキャッシュにデータが書き込まれることはありません。

          <OptionReference>
            EntitiesByDomainTypeQuery.FETCH_POLICY_TYPE.CACHE_AND_NETWORK、EntitiesByDomainTypeQuery.FETCH_POLICY_TYPE.CACHE_FIRST、EntitiesByDomainTypeQuery.FETCH_POLICY_TYPE.CACHE_ONLY、EntitiesByDomainTypeQuery.FETCH_POLICY_TYPE.NETWORK_ONLY、EntitiesByDomainTypeQuery.FETCH_POLICY_TYPE.NO_CACHE、
          </OptionReference>
      </td>
    </tr>

    <tr>
      <td>
        `filters` <h5>文字列</h5>|(形状|形状|形状)\[]
      </td>

      <td>
        エンティティを絞り込むために使用されるフィルター。これはフィルターの配列であり、次の 3 つのフィルターが考えられます。

        * 検索クエリフィルター: `Object<type: string = "searchQuery", value: string>`
        * エンティティタイプフィルター: `Object<type: string = "entityType", Object<domain: string, type: string>>`
        * タグフィルター: `Object<type: string = "tag", Object<key: string, value: string>>`

        ```js
        const filters = [
          {
            type: 'searchQuery',
            value: 'foo',
          },
          {
            type: 'entityType',
            value: { domain: 'APM', type: 'APPLICATION' },
          },
          {
            type: 'tag',
            value: { key: 'environment', value: 'production' },
          },
          {
            type: 'tag',
            value: { key: 'team', value: 'bar' },
          },
        ];
        ```
      </td>
    </tr>

    <tr>
      <td>
        `includeSummaryMetrics` <h5>ブール値</h5>
      </td>

      <td/>
    </tr>

    <tr>
      <td>
        `includeTags` <h5>ブール値</h5>
      </td>

      <td>
        `true`の場合、返されるエンティティにはタグが含まれます。
      </td>
    </tr>

    <tr>
      <td>
        `limit` <h5>ナンバー</h5>
      </td>

      <td>
        ページ区切り、各ページで取得するエンティティの数。
      </td>
    </tr>

    <tr>
      <td>
        `pollInterval` <h5>ナンバー</h5>
      </td>

      <td>
        新しいデータをポーリングする間隔（ミリ秒単位）。 定期的なポーリングを回避するには、ゼロに設定します。
      </td>
    </tr>

    <tr>
      <td>
        `skip` <h5>ブール値</h5>
      </td>

      <td>
        `true`に設定すると、クエリはレンダリングから完全にスキップされます。
      </td>
    </tr>

    <tr>
      <td>
        `sortBy` <h5>列挙型\[]</h5>
      </td>

      <td>
        エンティティ検索結果を並べ替えるために使用される基準の配列。

        <OptionReference array>
          EntitiesByDomainTypeQuery.SORT_TYPE.アラート、EntitiesByDomainTypeQuery.SORT_TYPE.ドメイン、EntitiesByDomainTypeQuery.SORT_TYPE.MOST_RELEVANT、EntitiesByDomainTypeQuery.SORT_TYPE.NAME、EntitiesByDomainTypeQuery.SORT_TYPE.REPORTING、EntitiesByDomainTypeQuery.SORT_TYPE.TYPE、
        </OptionReference>
      </td>
    </tr>
  </tbody>
</table>

### メソッド

### `EntitiesByDomainTypeQuery.query`

<FunctionDefinition
  arguments={[{"description":"Object containing the query options. Any `EntitiesByDomainTypeQuery` prop is a valid option except `children` and `pollInterval`.","name":"props","type":"Object"}]}
  returnValue={{"description":"","type":"PromiseQueryResult"}}
/>

### 型定義

<TypeDefReference typeDef={{"name":"PromiseQueryResult","properties":[{"description":"Runtime error with `graphQLErrors` and `networkError` properties.","name":"error","type":"ApolloClient.ApolloError"},{"description":"Object containing the result of your query.","name":"data","type":"Object"},{"description":"If not `null`, `fetchMore` allows you to load more results for your query. New data is merged with previous data.","name":"fetchMore","type":"function|null"},{"description":"Refetch the query.","name":"refetch","type":"function"}]}}/>

<TypeDefReference typeDef={{"name":"QueryResult","properties":[{"description":"Indicates that the request is in flight.","name":"loading","type":"boolean"},{"description":"Runtime error with `graphQLErrors` and `networkError` properties.","name":"error","type":"ApolloClient.ApolloError"},{"description":"Object containing the result of your query.","name":"data","type":"Object"},{"description":"If not `null`, `fetchMore` allows you to load more results for your query. New data is merged with previous data.","name":"fetchMore","type":"function|null"},{"description":"Refetch the query.","name":"refetch","type":"function"}]}}/>