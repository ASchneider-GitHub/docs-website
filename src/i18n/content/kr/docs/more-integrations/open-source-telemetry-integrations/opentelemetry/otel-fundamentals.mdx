---
title: OpenTelemetry 기본 사항
metaDescription: OpenTelemetry fundamentals
freshnessValidatedDate: never
translationType: machine
---

이 장에서는 OpenTelemetry의 기본 사항을 알아봅니다. 특히 OpenTelemetry 표준 및 구현의 핵심 개념과 구성 요소를 소개합니다. 이는 애플리케이션에서 이를 사용하는 방법, 시기, 이유를 배우는 데 도움이 됩니다.

## 목표 [#objectives]

이 장에서는 다음과 같은 질문에 대한 답을 배웁니다.

* OpenTelemetry란 무엇입니까?
* 내가 왜 그것에 관심을 가져야 합니까?
* 어떻게 사용하나요?

## 전제 지식 [#prerequisite-knowledge]

이 장을 읽기 전에 다음을 포함하여 텔레메트리 개념에 대해 잘 알고 있어야 합니다.

* 텔레메트리란 무엇인가
* 텔레메트리의 작동 방식
* 텔레메트리가 지원하는 데이터 유형
* 트레이는 무엇인가요?

다음 사항도 숙지해야 합니다.

* 핵심 가치 쌍, 함수, 클래스 등 일반적인 프로그래밍 개념
* 라이브러리, 프레임워크, 저장소와 같은 조직 구조 프로그래밍
* 요청, 응답, 상태 코드와 같은 일반적인 네트워킹 개념

<Steps>
  <Step>
    ## 오픈 텔레메트리 [#otel]

    [OpenTelemetry](https://opentelemetry.io) 임시 사용자, 클라우드 제공업체 및 옵저버빌리티 리더(뉴렐릭 포함)로 구성된 대규모 개발자 커뮤니티에서 지원하는 개방형 일러스트레이션의 흥미롭고 새로운 표준입니다. 이전 버전인 [OpenTracing](https://opentracing.io) 과 마찬가지로 CNCF 프로젝트이며 현재 [성숙](https://landscape.cncf.io/card-mode?project=incubating) 단계에 있습니다.

    OpenTelemetry AI 모니터링:

    * 텔리메트리 데이터를 수집하고 백앤드 플랫폼으로 보내는 방법을 표준화합니다. 이 표준을 사용하면 클라이언트와 관찰 플랫폼이 모두 데이터의 모양에 동의하므로 더 이상 데이터를 활용하기 위해 특정 플랫폼의 생태계에 갇힐 필요가 없습니다.

    * 텔레메트리 데이터에 대한 더 나은 엔드투엔드 가시성을 제공합니다. OpenTelemetry 라이브러리와 프레임워크가 플랫폼에 구애받지 않고 구현에 독립적인 방식으로 텔레메트리 데이터를 생성하는 방법을 정의합니다. 이는 더 많은 도구가 OpenTelemetry 채택할 수 있다는 것을 의미하며, 이는 특히 다른 기술을 사용하는 옵저버빌리티에서 더 나은 옵저버빌리티로 이어집니다.

      OpenTelemetry 텔레메트리 데이터의 모양과 사용 방법을 포함한 사양과 가장 널리 사용되는 프로그래밍 언어에서 해당 사양을 즉시 구현하는 기능을 모두 제공하여 이러한 목표를 달성합니다.

    * 사양. OpenTelemetry는 무엇보다도 사양입니다. 이는 HTML 템플릿 데이터의 모양에 대한 표준 정의와 OpenTelemetry 소스를 구축하고 사용하는 방법에 대한 설명을 제공합니다.

    * 구현. OpenTelemetry 의 API 및 SDK 사양은 텔리메트리 데이터 작업을 위한 클래스, 함수 및 설정 메커니즘을 정의합니다. 그러나 OpenTelemetry는 가장 널리 사용되는 여러 프로그래밍 언어의 표준을 준수하는 구현도 제공합니다.

      <Callout variant="tip">
        특정 플랫폼 솔루션은 OpenTelemetry 보다 백앤드 플랫폼의 더 많은 기능을 지원하는 경우가 많으며 뉴렐릭도 예외는 아닙니다. 오늘날 이는 사실이지만 OpenTelemetry가 성숙해짐에 따라 이러한 격차는 줄어들 것입니다.

        플랫폼이 독점 에이전트를 지원하는 방식과 OpenTelemetry를 지원하는 방식을 비교하려면 [설명서를](/docs/more-integrations/open-source-telemetry-integrations/opentelemetry/opentelemetry-introduction//#choice) 읽어보세요.
      </Callout>
  </Step>

  <Step>
    ## OpenTelemetry 사양 [#otel-specification]

    이 사양은 HTML 템플릿 데이터의 모양에 대한 표준 정의와 OpenTelemetry 소스를 구축하는 방법에 대한 설명을 제공합니다.

    구체적으로 다음을 설명합니다.

    * 지원하는 각 텔레메트리 데이터 유형에 대한 **데이터 모델입니다** . 이 사양에는 유선을 통해 데이터를 전송하기 위한 프로토콜과 일반적인 작업 및 기술에 대한 데이터를 설명하기 위한 기존 속성이 포함되어 있습니다.

    * 스프레드시트 데이터가 일관된 방식으로 생성되도록 보장하는 클래스와 함수로 구성된 독창적인 프로그래밍 인터페이스(**API**)입니다.

    * 에 의해 생성된 델메트리 데이터를 구성, 처리 및 내보내기 위한 메커니즘을 갖춘 소프트웨어 개발 키트(**SDK**) 입니 다 API.

      표준화된 데이터 모델은 개발자와 관측 플랫폼이 스프레드시트 데이터 구조의 모양, 코드로 표현되는 방식, 서비스 간에 직렬화 및 전송되는 방식에 동의할 수 있기 때문에 유용합니다. 최종 사용자인 귀하는 데이터가 일관되게 생성되고 형식화된다는 확신을 갖고 사양을 준수하는 경쟁 플랫폼과 도구 중에서 선택할 수 있습니다.

      계측을 구축하는 표준 방법은 지원되는 모든 프로그래밍 언어에서 일관성을 제공합니다. OpenTelemetry 사양을 준수하는 도구를 사용하여 설계를 수행한다면 해당 도구가 어떻게 작동하는지, 그리고 일관된 방식으로 텔레메트리 데이터를 생성하는지 알게 될 것입니다.

      <Callout variant="tip">
        OpenTelemetry 사양의 다양한 구성 요소를 분류하는 것이 도움이 됩니다. 개발자는 데이터 사양을 준수하지만 API 또는 SDK 사양을 준수하지 않는 계측 라이브러리를 만들 수 있습니다. 즉, 해당 라이브러리는 OpenTelemetry 사양과 일치하는 데이터를 계속 생성하고 전송하는 동시에 다른 인터페이스와 설정 메커니즘을 가질 수 있습니다.

        사양과 해당 구성 요소에 대한 자세한 내용은 이후 단원에서 알아봅니다.
      </Callout>
  </Step>

  <Step>
    ## OpenTelemetry 데이터 모델 사양 [#otel-data-model]

    데이터 모델은 텔레메트리 데이터 구조의 모양을 지정합니다. OpenTelemetry에서는 이러한 데이터 구조를 **신호** 라고 합니다. 지원되는 신호는 이 과정의 앞부분에서 배운 텔레메트리 데이터 유형인 트레이스, 지표 및 로그와 대부분 일치합니다.

    각 신호에는 다음을 포함하는 자체 데이터 모델 사양이 있습니다.

    * **의미론적 규칙**: 일반적인 작업, 기술, 이벤트 및 프로토콜을 설명하는 기존 속성입니다.

    * **OTLP(OpenTelemetry Protocol) 사양**: 각 데이터 신호를 인코딩하고 OpenTelemetry의 교환 프로토콜을 통해 전송하는 방법에 대한 설명입니다.

      데이터 모델이 제공하는 것이 무엇인지 더 구체적으로 알아보려면 트레이스 데이터 모델을 살펴보세요.
  </Step>

  <Step>
    ## 트레이스 데이터 모델 의미 규칙 [#trace-data-model]

    OpenTelemetry Traces 신호는 연결된 범위의 계층적 컬렉션으로 구성됩니다. 각 범위는 범위 이름, 시작 시간, 종료 시간과 같은 메타데이터 필드와 속성 목록, 이벤트 목록으로 구성됩니다. 범위와 포함된 필드에 대한 이러한 정의는 트레이스에 대한 OpenTelemetry 데이터 사양을 준수하는 모든 텔넷리 도구에 보편적입니다.

    이름 필드는 범위가 나타내는 작업을 식별합니다. 예를 들어 이름은 웹 서비스 입체포인트 또는 함수일 수 있습니다.

    시작 시간 및 종료 시간 필드는 각각 작업이 시작된 시간과 작업이 종료된 시간을 나타냅니다. 이 시간은 모든 하위 작업을 포함하여 작업의 총 경과 시간을 나타냅니다.

    다른 중요한 [범위 필드](https://opentelemetry.io/docs/reference/specification/trace/api/#span) 도 있으며, 그 중 일부는 특히 OpenTelemetry 의 트레이스 구현과 관련이 있기 때문에 이후 단원에서 자세히 알아봅니다. 스팬 모델을 포함한 모든 OpenTelemetry 데이터 모델의 간단하지만 정말 중요한 구성 요소 중 하나는 **속성** 입니다.

    ### 속성 [#attributes]

    속성은 강조하려는 기능을 나타내는 핵심 가치 쌍입니다. 예를 들어 범위가 장바구니에 제품을 추가하는 사용자에 대한 온라인 상점에 대한 웹 요청을 나타내는 경우 제품 ID를 범위의 속성으로 저장할 수 있습니다. 이는 사용자 정의 속성의 예입니다.

    일반적인 작업, 기술, 개념 및 프로토콜을 설명하기 위한 일반적인 속성도 있습니다. 예를 들어 데이터베이스 쿼리를 나타내는 범위에는 데이터베이스 사용자를 나타내는 `db.user` 이라는 속성이 있어야 합니다. 요청을 처리하는 웹 서비스를 나타내는 범위에는 노드의 포트 번호를 저장하는 `net.peer.port` 이라는 속성이 있어야 합니다. 의미론적 규칙이라고 하는 이러한 규칙은 이러한 공통 기능의 키와 값을 표준화합니다.

    HTTP, gRPC 및 메시징 프로토콜과 같은 널리 사용되는 기술을 지원하는 라이브러리는 작업을 설명할 때 이러한 의미 체계 규칙을 사용해야 합니다. 이러한 키가 모두 필요한 것은 아니지만 라이브러리가 속성의 데이터를 캡처하는 경우 규칙을 따라야 합니다.

    <Callout variant="tip">
      이러한 규칙은 이러한 특성을 무엇이라고 부를지에 대한 도구 개발자를 통합하는 동시에 백앤드 감시 플랫폼에도 도움이 됩니다. 기존 속성은 감시 플랫폼이 OpenTelemetry 구현에서 일관성을 기대할 수 있음을 의미합니다. 이러한 일관성을 활용하여 해당 속성을 활용하는 특정 사용자 경험과 도구를 구축할 수 있습니다.

      예를 들어 뉴렐릭은 데이터베이스 작업을 나타내는 범위에 널리 채택된 속성이 포함되어 있다는 것을 알고 있으므로 프로그래밍 방식으로 데이터의 속성을 찾아 이를 사용하여 특정 환경을 만들 수 있습니다.
    </Callout>

    속성과 마찬가지로 범위 이벤트는 Traces 데이터 모델의 또 다른 중요한 구성 요소입니다.

    ### 스팬 이벤트 [#span-events]

    범위 이벤트는 범위 작업 중에 발생하는 일을 나타냅니다. 예를 들어 함수가 예외를 발생시키는 경우 범위 이벤트에서 해당 예외에 대한 세부 정보를 캡처할 수 있습니다.

    연관된 범위와 마찬가지로 범위 이벤트에는 메타데이터, 특히 이름과 타임스탬프는 물론 이벤트의 기능을 강조하는 일부 속성도 있습니다.

    예외 이벤트의 경우 해당 속성 중 일부는 의미론적 규칙에 해당합니다. 예를 들어 예외 이벤트는 `exception.stacktrace` 이라는 속성이 있는 경우 해당 스택 추적을 해당 속성에 저장합니다. 메시지가 있는 경우 `exception.message` 이라는 속성에 메시지를 저장합니다. Span 이벤트는 Span 작업 중에 발생하는 상황을 이해하는 데 정말 유용합니다.

    <Callout variant="tip">
      뉴렐릭과 같은 일부 서비스는 이벤트를 최고 수준의 데이터 구조로 취급할 수 있습니다. OpenTelemetry에서 이벤트는 범위와 직접적으로 관련됩니다.
    </Callout>

    OpenTelemetry 데이터 모델 사양이 신호의 메타데이터와 의미 체계 규칙을 정의한다는 것을 배웠습니다. 범위의 경우 여기에는 범위 이름, 타임스탬프, 속성, 의미 체계, 이벤트 등이 포함됩니다. 그러나 이 사양은 또한 신호가 텔레메트리 클라이언트에서 전송될 수 있도록 직렬화되어야 하는 방법도 정의합니다.
  </Step>

  <Step>
    ## OpenTelemetry 프로토콜(OTLP) [#otel-protocol]

    OpenTelemetry 사양에는 네트워크 서비스 간에 데이터가 직렬화, 역직렬화 및 전송되는 방식을 정의하는 교환 프로토콜인 OTLP가 포함되어 있습니다. 이 프로토콜의 목표는 데이터 모델을 밀접하게 준수하고 [다른 텔레메트리 프로토콜에 존재하는 문제를](https://opentelemetry.io/docs/reference/specification/protocol/requirements/#known-issues-with-existing-protocols) 해결하는 직렬화 스키마를 지정하는 것입니다. 또한 데이터를 직렬화하여 전송할 수 있는 클라이언트를 일반적으로 구현하는 방법과 직렬화된 데이터를 수용하고 응답에서 성공 또는 실패를 표시할 수 있는 서버를 구현하는 방법을 정의하는 AI 모니터링도 포함됩니다.

    OTLP는 프로토콜 버퍼를 사용하여 텔레메트리 데이터와 이를 전송하기 위한 gRPC 또는 HTTP를 직렬화합니다. 프로토콜은 텔레메트리 클라이언트부터 데이터와 서비스, 에이전트, 수집기 및 전달자를 수신하는 관찰 플랫폼까지 모든 노드에서 작동합니다.

    OTLP는 OpenTelemetry 데이터 사양과 관련이 있습니다. 사양은 각 신호에 대한 데이터가 높은 수준에서 어떻게 보이는지 정의할 뿐만 아니라 코드 레벨에서도 어떻게 보이는지 지정하기 때문입니다. 특히 데이터를 직렬화하고 이를 유선으로 보내는 데 사용하는 프로토콜 버퍼 스키마를 정의합니다.

    다음은 [Traces 프로토콜 버퍼 스키마](https://github.com/open-telemetry/opentelemetry-proto/blob/main/opentelemetry/proto/trace/v1/trace.proto) 의 스니펫입니다.

    ```
    message Span {
    bytes trace_id = 1;
    bytes span_id = 2;
    string trace_state = 3;
    bytes parent_span_id = 4;
    string name = 5;
    SpanKind kind = 6;
    fixed64 start_time_unix_nano = 7;
    fixed64 end_time_unix_nano = 8;
    repeated opentelemetry.proto.common.v1.KeyValue attributes = 9;
    uint32 dropped_attributes_count = 10;
    repeated Event events = 11;
    uint32 dropped_events_count = 12;
    repeated Link links = 13;
    uint32 dropped_links_count = 14;
    Status status = 15;
    }
    ```

    이 메시지는 aTrays의 범위를 나타냅니다. 트레이스가 어떻게 구현되는지 아직 배우지 않았기 때문에 처음 몇 개의 필드를 인식하지 못할 수도 있지만 대부분의 다른 필드는 익숙해 보일 것입니다.

    * 메시지의 **다섯 번째** 필드는 범위의 이름입니다. 이전에 배운 것처럼 범위의 이름은 범위가 나타내는 작업을 식별하는 문자열입니다.
    * **일곱 번째** 와 **여덟 번째** 필드는 각각 범위의 시작 및 종료 타임스탬프입니다. 이는 UNIX 시대(1970년 1월 1일) 이후의 나노초 수를 나타내는 8바이트 정수로 저장됩니다. 형식화된 타임스탬프 문자열을 보내는 것보다 유선을 통해 정수를 보내는 것이 더 효율적입니다.
    * **9번째** 필드는 범위의 속성을 `KeyValue` 요소의 "반복" 데이터 유형으로 표시되는 컬렉션으로 나타냅니다.
    * **11번째** 필드는 `Event` 객체 컬렉션을 저장합니다.

    스키마에서 기본 데이터 유형보다 더 복잡한 `Event` 및 기타 맞춤 데이터 유형에는 자체 정의가 있습니다. 이 경우 다음이 가능합니다.

    ```
    message Event {
    fixed64 time_unix_nano = 1;
    string name = 2;
    repeated opentelemetry.proto.common.v1.KeyValue attributes = 3;
    uint32 dropped_attributes_count = 4;
    }
    ```

    이는 이전 강의에서 배운 데이터 모델과 거의 일대일로 일치하므로 익숙하게 보일 것입니다.

    데이터 사양을 참조하거나 작업할 때 OpenTelemetry는 여전히 진화하는 제품이라는 점을 명심하는 것이 중요합니다. 일부 데이터 신호는 안정적이고 장기간 지원되며 이전 버전과 호환되지 않는 변경 사항이 있는 후속 마이너 릴리스가 없음이 보장됩니다. 그러나 다른 것들은 실험적이거나 현재 안정성이 보장되지 않는 테스트 중입니다. [OpenTelemetry-proto 주체](https://github.com/open-telemetry/opentelemetry-proto#maturity-level) **Maturity Level** \[의 성숙도] 수준 차트를 확인하여 각 스키마의 성숙도를 확인하세요.

    엄청난! 다음을 포함하여 OpenTelemetry 데이터 사양에 대해 모두 배웠습니다.

    * 어떤 신호가 있나요?
    * 사양에서 각 신호에 대해 정의하는 내용
    * 트레이스 데이터 모델의 모습
    * OpenTelemetry 범위에 포함되는 속성
    * 스팬 이벤트란?
    * 사양이 데이터 모델에 따라 OTLP 스키마를 정의하는 방법

    그러나 사양은 텔레메트리 데이터를 정의하는 것으로 끝나지 않습니다. 또한 해당 데이터와 상호 작용하기 위한 인터페이스를 지정합니다.
  </Step>

  <Step>
    ## OpenTelemetry API 사양 [#otel-api-spec]

    지금까지 OpenTelemetry 사양이 각 텔메트리 데이터 신호에 대한 데이터 모델, 의미 체계 및 OTLP 스키마를 정의하는 방법을 배웠습니다. 그러나 사양은 텔레메트리 데이터의 모양보다 더 많은 것을 정의합니다. 또한 해당 데이터로 작업하는 방법도 정의합니다.

    OpenTelemetry API 사양은 데이터 신호와 상호 작용하는 데 사용하는 클래스와 함수를 설명합니다. 예를 들어 OpenTelemetry 구현이 범위를 생성하거나 메트릭 측정값을 보고하는 방법을 설명합니다.

    OpenTelemetry 계측 개발자에게 이 사양은 다른 OpenTelemetry 호환 도구와 일치하는 API를 구축하기 위한 청사진을 제공합니다. API를 사용하는 프레임워크, 라이브러리 및 앱 개발자의 경우 사양은 일관성을 보장하고 모든 호환 도구와 상호 작용할 수 있는 방법에 대한 문서를 제공합니다.

    API 사양에는 두 가지 필수 구성 요소가 있습니다.

    * 텔레메트리 데이터 작업에 사용하는 **인터페이스 정의**
    * 해당 인터페이스의 **최소한의 구현**
  </Step>

  <Step>
    ## 인터페이스 정의 [#defining-interface]

    API 사양이 제공하는 첫 번째 사항은 신호와 상호 작용하기 위한 클래스 및 함수에 대한 정의입니다.

    예를 들어, 사양에서는 Traces 작업을 위한 세 가지 기본 클래스를 정의합니다.

    * `TracerProvider` 짐작할 수 있듯이 트레이서를 제공하는 클래스입니다. 일부 앱은 여러 트레이서 공급자를 사용할 수 있지만 일반적으로 단일 전역 공급자를 사용합니다. ATray서 제공자는 스팬을 처리하는 방법 및 스팬을 샘플링하는 방법과 같은 특정 설정을 보유합니다.

    * `Tracer` 프로세스에 대한 정보를 수집하는 범위를 만드는 데 사용하는 클래스입니다. 트레이서가 아닌 트레이서 공급자는 트레이서가 스팬을 생성하는 방법과 기록 시 해당 스팬으로 수행하는 작업을 지시하는 설정을 보유하고 있다는 점을 기억하세요.

    * `Span` 작업에 대한 데이터를 캡처합니다. 여러 범위가 트레이스를 구성합니다. 데이터 모델 사양을 학습하면서 OpenTelemetry 범위가 어떤 모습인지에 대해 많은 것을 배웠습니다. 그러나 범위에는 보유하는 데이터보다 더 많은 것이 있습니다.

      예를 들어 범위에는 기간을 결정하는 시작 및 종료 메서드가 있습니다. 여기에는 `IsRecording()` 이라는 범위 값을 업데이트할 수 있는지 확인하는 데 사용하는 메서드가 있습니다. 또한 속성 및 이벤트 추가와 같이 해당 값을 업데이트하는 방법도 있습니다. 신호와 상호 작용하기 위한 이러한 모든 인터페이스는 API 사양에 의해 정의됩니다.

      <Callout variant="tip">
        사양은 신호와 상호 작용하는 데 사용하는 클래스와 함수를 정의하지만 메서드 이름의 대/소문자와 같은 언어 수준 세부 사항은 구현 간에 차이가 있을 수 있습니다.
      </Callout>

      API 사양이 정의하는 또 다른 측면은 "최소 구현"이라고 부르는 것입니다.
  </Step>

  <Step>
    ## 최소 구현 \[minimal-implementation]

    API는 데이터 작업에 사용하는 인터페이스를 정의하지만 사실상 아무 작업도 수행하지 않는 구현도 필요합니다. 이 "최소" 구현은 오버헤드가 매우 낮고 부작용이 없습니다.

    API XML 저장소를 포함하여 XML 데이터를 처리하는 프로그램에서 사용됩니다. 네트워크 요청이나 데이터베이스와 같은 특정 기술과 상호 작용하기 위한 프레임워크; 그리고 그 도구를 사용하는 기능. 그러나 애플리케이션 개발자만이 OpenTelemetry API에서 생성된 데이터를 어떻게 사용하고 싶은지 알고 있습니다. 최소한의 구현을 통해 개발자는 개발자가 API 사용하기를 원하는지 여부에 관계없이 코드에 합성을 구축할 수 OpenTelemetry 있습니다.

    예를 들어, 데이터베이스 라이브러리 개발자가 자신의 코드를 축소하여 해당 사용자가 자신이 생성한 델메트리 데이터를 사용할 수 있는 옵션을 갖게 되기를 원한다고 가정해 보겠습니다. 개발자는 트레이서 공급자를 구성하고 이를 사용하여 트레이서를 만든 다음 해당 트레이서를 사용하여 코드 전체에 걸쳐 범위를 만듭니다. 사용자가 HTML 템플릿 데이터를 원하는지 여부를 모르거나 신경 쓰지 않고도 이 모든 것, 그 이상을 수행할 수 있지만, HTML은 부작용 없이 성능이 좋을 것이라는 확신을 가지고 있습니다.

    사용자가 OpenTelemetry를 사용하려는 경우 구현을 구성합니다. API를 사용하는 라이브러리는 사용자가 원하는 방식으로 적절한 데이터를 자동으로 생성하고 전송하기 시작합니다. 사용자가 OpenTelemetry 사용하고 싶지 않은 경우 API 실제로 어떤 Telmet리 데이터도 생성하지 않는 최소한의 구현을 사용합니다.

    이는 OpenTelemetry API를 사용하는 개발자에게 일관성을 제공합니다. 또한 일종의 특별한 라이브러리 버전을 요구하지 않음으로써 개발자의 부담을 덜어줍니다. 이러한 장벽을 제거함으로써 OpenTelemetry 훨씬 더 쉽게 채택할 수 있으며, 채택이 많아지면 격차가 줄어들고 모든 사람에게 더 나은 텔레메트리 데이터가 제공됩니다.

    데이터 모델 사양과 마찬가지로 각 신호에 대한 API 사양은 서로 다른 성숙 단계에 있다는 점을 기억하는 것이 중요합니다. API 사양 성숙도에 대한 최신 정보를 보려면 [OpenTelemetry 상태 페이지를](https://opentelemetry.io/status/) 확인하세요.

    이제 API 사양이 정의하는 내용에 대한 몇 가지 예를 살펴보았으므로 API 사양이 정의하지 않은 내용을 명확히 하기 위해 한발 뒤로 물러서는 것이 중요합니다.
  </Step>

  <Step>
    ## 관심사 분리하기 \[separating-concerns]

    API는 OpenTelemetry 신호와 상호작용하는 데 사용하는 인터페이스를 정의합니다. 이를 사용하여 텔리메트리 데이터를 생성하는 코드를 설정합니다. API 자체는 실제로 데이터를 생성하지 않습니다. 그것이 구현의 책임입니다.

    OpenTelemetry는 신호의 인터페이스와 인터페이스와 상호 작용할 때 실행되는 논리인 구현을 분리합니다. 이는 API 사용자가 API가 어떻게 구현되는지 정확히 알거나 신경 쓰지 않아도 되도록 보호합니다. 또한 구현을 구성할 수도 있습니다.

    API 사용자는 인터페이스 뒤에 있는 논리를 알 수 없기 때문에 해당 논리는 사용자가 데이터를 사용하려는 방식에 따라 다양한 형태를 취할 수 있습니다. API 구현을 구성하는 것이 SDK의 목적입니다.
  </Step>

  <Step>
    ## 오픈 OpenTelemetry SDK [#otel-sdk]

    OpenTelemetry는 지원하는 각 신호에 대한 사양을 제공합니다. 여기에는 데이터 모델 및 API에 대한 설명이 포함되어 있지만 SDK에 대한 설명도 포함되어 있다는 것을 이미 확인했습니다. SDK 사양은 API 뒤에 있는 논리를 구현하기 위한 요구 사항을 정의합니다. SDK 사양에 대한 자세한 내용을 알아보기 전에 SDK를 유용하게 사용할 수 있는 방법에 대한 그림을 찾을 수 있습니다.

    OpenTelemetry 사용하여 라이브러리에서 지원하는 기능을 구축한다고 상상해 보세요. 지금까지는 텔리메트리 데이터를 어떻게 사용할지 정의하지 않았기 때문에 해당 라이브러리와 상호 작용하는 API 최소한의 구현을 사용하고 있습니다. 즉, 라이브러리는 데이터를 생성하거나 전송하지 않지만 이러한 기능을 갖추고 있습니다. 이제 해당 계측을 사용하도록 SDK를 구성할 준비가 되었습니다.

    먼저 텔레메트리 데이터를 어떻게 사용할지 결정하는 것부터 시작합니다. 트레이스의 경우 스팬을 처리하는 방법, 샘플링하는 방법, 수집된 후 보내는 방법과 위치를 결정합니다. API가 데이터를 처리하는 방법을 알고 나면 SDK의 인터페이스를 사용하여 구현을 구성합니다.

    사양은 SDK 구성을 위한 세 가지 메커니즘을 정의합니다.

    * 상호 교환 가능한 구현을 제공하는 **플러그인**

    * 설정을 보유하거나, 적용을 허용하거나, 리소스를 생성하는 환경 변수 및 개체와 같은 **생성자**

    * 텔레메트리 데이터를 생성하는 환경을 식별하는 **리소스**

      플러그인을 적용하고 생성자를 구성하면 API 이중결합은 원하는 방식으로 결과를 생성합니다. 더 이상 최소 구현을 사용하지 않습니다. 대신 구성한 구현을 사용합니다. API는 어떤 구현이 사용되는지 모르거나 신경쓰지 않기 때문에 계측에는 코드 변경이 필요하지 않습니다.

      SDK 작동 방식에 대한 높은 수준의 예를 살펴보았으므로 이제 사양이 플러그인 및 생성자 인터페이스를 정의하는 방법을 알아볼 차례입니다.
  </Step>

  <Step>
    ## SDK 플러그인 [#sdk-plugins]

    API가 데이터를 처리하는 방법을 정의하는 방법 중 하나는 플러그인을 사용하는 것입니다. 예를 들어, 특정 방식으로 데이터를 샘플링하려는 경우 필요에 맞게 샘플러 플러그인을 사용할 수 있습니다. 다른 샘플러로 변경하려면 플러그인을 교체하면 됩니다.

    SDK 사양은 SDK가 허용하는 플러그인 유형과 해당 플러그인이 구현해야 하는 인터페이스를 모두 정의합니다. 이 인터페이스 정의로 인해 개발자가 새 플러그인을 쉽게 만들 수 있습니다. 그리고 사용자 정의 동작이 필요한 경우 사양을 사용하여 직접 작성할 수도 있습니다.

    TheTrays SDK는 다음과 같은 여러 유형의 삽입을 허용합니다.

    * **Span 내보내기:** 데이터를 인코딩하여 소비자에게 전송합니다.

    * **스팬 프로세서:** 스팬 데이터를 강화하고 필터링한 다음 이를 내보내기자가 작업할 수 있는 형식으로 변환합니다.

    * **샘플러:** 사용자가 범위 샘플링을 제어할 수 있습니다.

      이러한 각 플러그인 유형에 대해 SDK 사양은 인터페이스 또는 필수 메서드를 정의합니다.

      예를 들어, 범위 내보내기 플러그인은 다음 두 가지 기능을 구현해야 합니다.

    * **내보내기:** 범위를 수신하여 직렬화하고 지정된 소비자에게 전송합니다.

    * **종료:** 내보내기 환경을 정리합니다.

      API 이중결합은 사양에서 요구하는 플러그인이 무엇인지 관계없이 적절한 시점에 이러한 함수를 호출할 수 있습니다.

      또한 사양은 SDK 구현에 포함되어야 하는 플러그인을 정의합니다. 예를 들어 SDK가 단순 범위 프로세서와 배치 프로세서를 제공해야 한다고 선언합니다. 단순 범위 프로세서 프로세스는 완료되자마자 범위를 확장합니다. 일괄 처리 프로세서는 완료된 범위를 내보내기 도구에 전달하기 전에 일괄 처리합니다.

      SDK 플러그인은 특정 방식으로 API 인터페이스를 구현하는 모듈식 논리적 구성 요소입니다. 귀하는 텔레메트리 데이터의 목표에 가장 적합한 바인딩을 선택합니다. 플러그인을 선택한 후에는 SDK 생성자를 사용하여 플러그인을 추가로 구성하고 API에 할당할 수 있습니다.
  </Step>

  <Step>
    ## SDK 생성자 [#sdk-constructors]

    사양에서는 OpenTelemetry 구현을 구성하는 방법으로 생성자를 정의합니다. 생성자에는 환경 변수와 설정 클래스가 포함됩니다.

    예를 들어 SDK는 이전 강의에서 배운 OpenTelemetry의 교환 프로토콜인 OTLP를 통해 데이터를 전송하기 위한 내장 내보내기 플러그인을 제공합니다. OTLP 내보내기 사양은 내보내기가 트레이스 데이터를 보내야 하는 URL을 지정하는 `OTEL_EXPORTER_OTLP_TRACES_ENDPOINT` 와 같이 이를 구성하는 데 사용하는 일부 환경 변수를 정의합니다.

    사양에서는 API 구현을 구성하는 데 사용하는 클래스도 정의합니다. 트레이스의 경우 이미 알아본 트레이서 공급자입니다. 범위를 생성하는 트레이서를 생성하려면 트레이서 공급자를 사용합니다. 트레이서 공급자는 범위가 생성, 처리 및 내보내지는 방법에 대한 설정을 보유합니다. API를 구현하기 위해 플러그인을 제공하는 방법입니다.

    OpenTelemetry SDK 사양은 끼워넣기 및 생성자와 함께 텔레메트리 데이터를 생성하는 환경을 식별하는 방법을 정의합니다. 이 SDK 구성 요소를 **리소스** 라고 합니다.
  </Step>

  <Step>
    ## 자원 [#resources]

    리소스를 사용하여 속성을 통해 프로젝트 환경을 식별합니다. 예를 들어 호스트를 설명하기 위해 호스트 이름 및 가상 머신 이미지에 대한 속성을 포함할 수 있습니다. 서비스를 설명하기 위해 서비스 네임스페이스와 버전을 포함할 수 있습니다. HTML 템플릿을 설명하기 위해 SDK 이름과 버전을 포함할 수 있습니다.

    OpenTelemetry 사양은 신호와 마찬가지로 리소스 의미 체계 규칙을 제공합니다. 리소스에 대해 유일하게 필요한 기존 속성은 `service.name` 입니다. [사양](https://opentelemetry.io/docs/reference/specification/resource/semantic_conventions/#semantic-attributes-with-sdk-provided-default-value) 에서 선택적인 기존 속성을 찾을 수 있습니다.

    환경에 대한 리소스를 생성한 후에는 생성자와 함께 이를 포함할 수 있습니다. 트레이스의 경우 이는 트레이서 공급자에 리소스를 연결한다는 의미입니다. 범위를 생성하면 해당 범위가 환경의 리소스와 연결됩니다.

    데이터 모델 및 API 사양과 마찬가지로 일부 SDK 사양은 다른 사양보다 더 성숙합니다. 예를 들어 리소스 사양은 안정적이지만 리소스 의미 규칙은 아직 실험적입니다. SDK 사양 성숙도에 대한 최신 정보를 보려면 [OpenTelemetry 상태 페이지를](https://opentelemetry.io/status/) 확인하세요.

    OpenTelemetry를 사양으로 많이 배웠습니다. OpenTelemetry를 중심으로 구축된 모든 것이 사양을 따르기 때문에 이는 OpenTelemetry를 이해하기 위한 기초입니다. 그러나 OpenTelemetry에는 널리 사용되는 여러 프로그래밍 언어로 사양을 구현하는 공식 코드 저장소도 포함되어 있습니다.
  </Step>

  <Step>
    ## OpenTelemetry 구현 [#otel-implementations]

    OpenTelemetry는 사양 그 이상입니다. 또한 가장 널리 사용되는 여러 프로그래밍 언어로 공식 구현을 제공합니다.

    * [.그물](https://github.com/open-telemetry/opentelemetry-dotnet)
    * [C++](https://github.com/open-telemetry/opentelemetry-cpp)
    * [얼랭/엘릭서](https://github.com/open-telemetry/opentelemetry-erlang)
    * [가다](https://github.com/open-telemetry/opentelemetry-go)
    * [자바](https://github.com/open-telemetry/opentelemetry-java)
    * [자바스크립트](https://github.com/open-telemetry/opentelemetry-js)
    * [PHP](https://github.com/open-telemetry/opentelemetry-php)
    * [파이썬](https://github.com/open-telemetry/opentelemetry-python)
    * [루비](https://github.com/open-telemetry/opentelemetry-ruby)
    * [녹](https://github.com/open-telemetry/opentelemetry-rust)
    * [빠른](https://github.com/open-telemetry/opentelemetry-swift)

    사양과 마찬가지로 이러한 구현도 진화하고 있습니다. [규정 준수 매트릭스를](https://github.com/open-telemetry/opentelemetry-specification/blob/main/spec-compliance-matrix.md) 확인하여 선호하는 언어가 어느 정도까지 진행되었는지 자세히 알아보세요.

    OpenTelemetry는 API를 사용하여 데이터를 생성하는 수동 및 자동 계측 형태를 제공합니다.

    ### 수동 계측 [#manual-instrumentation]

    수동 계측을 사용하려면 개발자가 SDK를 사용하여 API를 구성하고 API를 사용하여 데이터를 생성하고 내보내야 합니다. 트레이스의 관점에서 이는 트레이서 공급자를 만들고, 트레이서를 만들고, 데이터를 수집하려는 각 작업에 대한 범위를 만드는 것을 의미합니다. 기본적으로 라이브러리 또는 프레임워크를 사용하려는 경우 수동 리소스를 사용하세요.

    ### 자동 계측 [#automatic-instrumentation]

    자동 HTML은 사용자가 직접 코딩할 필요 없이 수동 HTML과 동일한 HTML HTML 데이터를 제공합니다. 자동 계측은 널리 사용되는 라이브러리 및 프레임워크로 제한되므로 해당 프로젝트 중 하나를 사용하는 애플리케이션 개발자인 경우에만 사용할 수 있습니다. 다행스럽게도 널리 사용되는 많은 오픈 소스 라이브러리 및 프레임워크에 대한 자동 계측을 찾을 수 있습니다.

    <Callout variant="tip">
      OpenTelemetry 개발자는 코드를 프로그래밍 방식으로 조작하여 자동으로 로그를 제공할 수 있습니다. 예를 들어, OpenTelemetry 저항 에이전트는 소스를 추가하기 위해 병력의 바이트코드를 다시 작성합니다. 그러나 라이브러리 계측도 제공할 수 있습니다. 이는 몇 가지 형태를 취할 수 있습니다.

      * OpenTelemetry는 라이브러리에 직접 구축될 수 있습니다.
      * 로그 코드는 리소스에 있는 특수 목적 확장 후크를 활용할 수 있습니다.
      * 래핑된 버전의 라이브러리에는 계측 계층이 포함될 수 있습니다.
    </Callout>

    ### 저장소 구조 [#repository-structure]

    OpenTelemetry 구현에는 SDK 인터페이스, API 인터페이스, 플러그인, 의미 체계 규칙을 비롯한 많은 구성 요소가 포함되어 있으며 해당 구현이 모두 동일하게 보이지는 않습니다. 구현된 언어에 관용적인 결정을 내릴 뿐만 아니라 개념을 다르게 분리합니다.

    예를 들어, 하나의 언어에는 모든 OpenTelemetry 코드에 대해 하나의 저장소가 있을 수 있습니다. 다른 언어에서는 수동 및 자동 로그를 자체적으로 분리할 수 있습니다. 선호하는 언어에 대해 자세히 알아보려면 [OpenTelemetry 설명서를](https://opentelemetry.io/docs/instrumentation/) 검토하세요.
  </Step>
</Steps>